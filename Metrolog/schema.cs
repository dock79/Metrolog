//------------------------------------------------------------------------------
// <auto-generated>
//     Этот код создан программой.
//     Исполняемая версия:4.0.30319.42000
//
//     Изменения в этом файле могут привести к неправильной работе и будут потеряны в случае
//     повторной генерации кода.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Windows;
using System.Windows.Input;
using System.Xml.Serialization;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using Microsoft.Win32.SafeHandles;
using System.Text.RegularExpressions;

namespace Metrolog
{
// 
// This source code was auto-generated by xsd, Version=4.7.2046.0.
//

/// <remarks/>
[System.SerializableAttribute()]
[System.Xml.Serialization.XmlRootAttribute(Namespace="urn://fgis-arshin.gost.ru/module-verifications/import/2020-06-19", IsNullable=false)]
public partial class application {
    
    private recInfo[] resultField;
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute("result")]
    public recInfo[] result {
        get {
            return this.resultField;
        }
        set {
            this.resultField = value;
        }
    }
}
	
	
public enum ApplicableType
{
	/// <remarks/>
    [Description("applicable")]    
    applicable,
    
    /// <remarks/>
    [Description("inapplicable")]    
    inapplicable
}

[SerializableAttribute]
public class RelayCommand : ICommand
{
        private Action<object> execute;
        private Func<object, bool> canExecute;
 
        public event EventHandler CanExecuteChanged
        {
            add { CommandManager.RequerySuggested += value; }
            remove { CommandManager.RequerySuggested -= value; }
        }
 
        public RelayCommand(Action<object> execute, Func<object, bool> canExecute = null)
        {
            this.execute = execute;
            this.canExecute = canExecute;
        }
 
        public bool CanExecute(object parameter)
        {
            return this.canExecute == null || this.canExecute(parameter);
        }
 
        public void Execute(object parameter)
        {
            this.execute(parameter);
        }
}

/// <remarks/>
[Serializable]
public partial class recInfo : INotifyPropertyChanged, INotifyDataErrorInfo 
{
    
	public recInfo()
	{
		miInfoField = new recInfoMiInfo();
		vrfDateField = null;
		validDateField = null;
		applicableField = new recInfoApplicable();    
		inapplicableField = new recInfoInapplicable();
		meansField = new recInfoMeans();
		conditionsField = new recInfoConditions();
		brief_procedureField = new recInfoBrief_procedure();
		protocolField = new recInfoProtocol();
		isBriefProcedureField = false;
		isProtocolField = false;
		_isValidateField = false;
		
		//ChangeFlag = false;
		miInfoField.PropertyChanged += OnPropertyChangeEventHandler;
		applicableField.PropertyChanged += OnPropertyChangeEventHandler;
		inapplicableField.PropertyChanged += OnPropertyChangeEventHandler;
		meansField.PropertyChanged += OnPropertyChangeEventHandler;
		conditionsField.PropertyChanged += OnPropertyChangeEventHandler;
		brief_procedureField.PropertyChanged += OnPropertyChangeEventHandler;
		protocolField.PropertyChanged += OnPropertyChangeEventHandler;
	}
	
	#region INotifyDataErrorInfo implementation

	private readonly Dictionary<string, List<string>> _errorsByPropertyName = new Dictionary<string, List<string>>();

	public event EventHandler<DataErrorsChangedEventArgs> ErrorsChanged;

	public IEnumerable GetErrors(string propertyName)
	{
		return _errorsByPropertyName.ContainsKey(propertyName) ? _errorsByPropertyName[propertyName] : null;
	}

	public bool HasErrors
	{
		get { return _errorsByPropertyName.Any(); }
	}

	private void OnErrorChanged(string propertyName)
	{
		if (ErrorsChanged != null) ErrorsChanged.Invoke(this, new DataErrorsChangedEventArgs(propertyName));
	}

	private void AddError(string propertyName, string error)
	{
		if (!_errorsByPropertyName.ContainsKey(propertyName))
			_errorsByPropertyName[propertyName] = new List<string>();
		if (!_errorsByPropertyName[propertyName].Contains(error))
		{
			_errorsByPropertyName[propertyName].Add(error);
			OnErrorChanged(propertyName);
		}
	}

	private void ClearErrors(string propertyName)
	{
		if (_errorsByPropertyName.ContainsKey(propertyName))
		{
			_errorsByPropertyName.Remove(propertyName);
			OnErrorChanged(propertyName);
		}
	}

	public void ClearAllErrors()
	{
		List<string> properties = new List<string>();
		foreach (KeyValuePair<string, List<string>> error in this._errorsByPropertyName)
			properties.Add(error.Key);
		this._errorsByPropertyName.Clear();
		foreach (string property in properties)
			this.OnPropertyChanged(property);
	}


	public void Validate()
	{
		miInfo.IsValidate = true;
		
		ClearErrors("signCipher");
		if (string.IsNullOrWhiteSpace(signCipherField))
			AddError("signCipher", "Поле \"Условный шифр знака поверки\" не заполнено.");
		if (signCipherField != null)
		{
			//ClearErrors("signCipher");
			Regex regex = new Regex("^[А-Я]{3}$");
			if (!regex.IsMatch(signCipherField.Trim())) AddError("signCipher", "Поле \"Условный шифр знака поверки\" должно состоять из трех букв [А-Я]");
		}
		
		ClearErrors("miOwner");
		if (string.IsNullOrWhiteSpace(miOwnerField))
			AddError("miOwner", "Поле \"Владелец СИ\" не заполнено.");

		ClearErrors("vrfDate");
		if (vrfDateField == null)
			AddError("vrfDate", "Поле \"Дата поверки СИ\" не заполнено.");

		ClearErrors("validDate");
		if (typeField == recInfoType.Item2)
		{
			if (validDate == null)
				AddError("validDate", "Поле \"Поверка действительна до\" не заполнено.");
		}

		if (applicableTypeField == ApplicableType.inapplicable)
			inapplicableField.IsValidate = true;
		else
			inapplicableField.IsValidate = false;

		ClearErrors("docTitle");
		if (string.IsNullOrWhiteSpace(docTitleField))
			AddError("docTitle", "Наименование документа, на основании которого выполнена поверка\" не заполнено.");

		meansField.IsValidate = true;
		
		conditionsField.IsValidate = true;

		if (isBriefProcedureField)
		{
			brief_procedureField.IsValidate = true;
		}
		else
		{
			brief_procedureField.IsValidate = false;
		}

		if (IsProtocol)
		{
			protocolField.IsValidate = true;
		}
		else
		{
			protocolField.IsValidate = false;
		}

	}

	[XmlIgnore] private bool _isValidateField;

	[XmlIgnore]
	public bool IsValidate
	{
		get { return _isValidateField; }
		set
		{
			if (value == this._isValidateField) return;
			this._isValidateField = value;
			if (!_isValidateField)
			{
				ClearAllErrors();
				miInfoField.IsValidate = false;
				inapplicableField.IsValidate = false;
				meansField.IsValidate = false;
				conditionsField.IsValidate = false;
				brief_procedureField.IsValidate = false;
				protocolField.IsValidate = false;
			}
			OnPropertyChanged();
		}
	}

	#endregion
	
	private void OnPropertyChangeEventHandler(object sender, PropertyChangedEventArgs e)
	{
		//if (PropertyChanged != null) PropertyChanged.Invoke(this, new PropertyChangedEventArgs(null));
		if (PropertyChanged != null) PropertyChanged.Invoke(this, new PropertyChangedEventArgs(e.PropertyName));
		//if (_isValidateField) Validate();
	}

	//[XmlIgnore]
	/*public bool ChangeFlag
	{
		get;
		set;
	}*/

	public void PostCreateLogic()
	{
		miInfoField.PropertyChanged += OnPropertyChangeEventHandler;
		miInfoField.PostCreateLogic();
		applicableField.PropertyChanged += OnPropertyChangeEventHandler;
		inapplicableField.PropertyChanged += OnPropertyChangeEventHandler;
		meansField.PropertyChanged += OnPropertyChangeEventHandler;
		conditionsField.PropertyChanged += OnPropertyChangeEventHandler;
		brief_procedureField.PropertyChanged += OnPropertyChangeEventHandler;
		protocolField.PropertyChanged += OnPropertyChangeEventHandler;
	}

	[OnDeserialized]
	private void OnDeserialized(StreamingContext context)
	{
		// Вызывается, когда процесс десериализации завершен.
		miInfoField.PropertyChanged += OnPropertyChangeEventHandler;
		miInfoField.PostCreateLogic();
		applicableField.PropertyChanged += OnPropertyChangeEventHandler;
		inapplicableField.PropertyChanged += OnPropertyChangeEventHandler;
		meansField.PropertyChanged += OnPropertyChangeEventHandler;
		conditionsField.PropertyChanged += OnPropertyChangeEventHandler;
		brief_procedureField.PropertyChanged += OnPropertyChangeEventHandler;
		protocolField.PropertyChanged += OnPropertyChangeEventHandler;
	}

	//private recInfo(string name)
	//{
	//}

	#region
	public event PropertyChangedEventHandler PropertyChanged;

	protected void OnPropertyChanged([CallerMemberName] string propertyName = "")
	{
		if (PropertyChanged != null) PropertyChanged.Invoke(this, new PropertyChangedEventArgs(propertyName));
		//PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
		if (_isValidateField) Validate();
	}
	#endregion

	private recInfoMiInfo miInfoField;
    
    private string signCipherField;
    
    private string miOwnerField;
    
    private System.DateTime? vrfDateField;
    
    private System.DateTime? validDateField;
    
    private bool validDateFieldSpecified;
    
    private recInfoType typeField = recInfoType.Item1;
    
    private bool calibrationField;
    
    //private object itemField;
    
    recInfoApplicable applicableField;
    
	recInfoInapplicable inapplicableField;
    
    private string docTitleField;
    
    private string metrologistField;
    
    private recInfoMeans meansField;
    
    private recInfoConditions conditionsField;
    
    private string structureField;
    
    private bool isBriefProcedureField;
    
    private recInfoBrief_procedure brief_procedureField;
    
    private string additional_infoField;
    
    private recInfoProtocol protocolField;
    
    private ApplicableType applicableTypeField;
    
    private bool isProtocolField;
   
    /// <remarks/>
    public ApplicableType ApplicableType {
        
    	get {
            return this.applicableTypeField;
        }
        set {            
    		if (value == this.applicableTypeField) return;
			this.applicableTypeField = value;
			OnPropertyChanged();    		
        }     	
    }
    
    /// <remarks/>   	
    public recInfoMiInfo miInfo {
        get {
            return this.miInfoField;
        }
        set {
	        if (value == this.miInfoField) return;
	        this.miInfoField = value;
	        OnPropertyChanged();
        }
    }
    
    /// <remarks/>
   	[Required (ErrorMessage ="Поле \"Условный шифр знака поверки\" не заполнено.", AllowEmptyStrings = false)]
    public string signCipher {
        get {
            return this.signCipherField;
        }
        set {
	        if (value == this.signCipherField) return;
	        this.signCipherField = value;
	        //if (PropertyChanged != null) PropertyChanged.Invoke(this, new PropertyChangedEventArgs("signCipher"));
	        OnPropertyChanged();
        }
    }
    
    /// <remarks/>
    [Required (ErrorMessage ="Поле \"Владелец СИ\" не заполнено.", AllowEmptyStrings = false)]
    public string miOwner {
        get {
            return this.miOwnerField;
        }
        set {
	        if (value == this.miOwnerField) return;
	        this.miOwnerField = value;
	        OnPropertyChanged();
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(DataType="date")]
    [Required (ErrorMessage ="Поле \"Дата поверки СИ\" не заполнено.", AllowEmptyStrings = false)] 
    public System.DateTime? vrfDate {
        get {
            return this.vrfDateField;
        }
        set {
	        if (value == this.vrfDateField) return;
	        this.vrfDateField = value;
	        OnPropertyChanged();
        }
    }
    
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(DataType="date")]
    public System.DateTime? validDate {
        get {
            return this.validDateField;
        }
        set {
           if (value == this.validDateField) return;
			this.validDateField = value;
			OnPropertyChanged();
        }
    }
    
    
    /// <remarks/>
    public recInfoType type {
        get {
            return this.typeField;
        }
        set {            
    		if (value == this.typeField) return;
			this.typeField = value;
			OnPropertyChanged();
        }
    }
    
    /// <remarks/>
    [Required (ErrorMessage ="Поле \"Признак поверки средства измерений с использованием результатов калибровки\" не заполнено.", AllowEmptyStrings = false)]
    public bool calibration {
        get {
            return this.calibrationField;
        }
        set {
            
    		if (value == this.calibrationField) return;
			this.calibrationField = value;
			OnPropertyChanged();
        }
    }
   
   
   public recInfoApplicable applicable
   {
   		get 
   		{
            return this.applicableField;
        }
        set 
        {
	        if (value == this.applicableField) return;
			this.applicableField = value;
			OnPropertyChanged();  
        }   
   }
    
	public recInfoInapplicable inapplicable
	{
		get
		{
            return this.inapplicableField;
        }
        set
        {            
    		if (value == this.inapplicableField) return;
			this.inapplicableField = value;
			OnPropertyChanged();
        }
	}
   
   
   
    /// <remarks/>
    [Required (ErrorMessage ="Поле \"Наименование документа, на основании которого выполнена поверка\" не заполнено.", AllowEmptyStrings = false)]
    public string docTitle {
        get {
            return this.docTitleField;
        }
        set {
	        if (value == this.docTitleField) return;
	        this.docTitleField = value;
	        OnPropertyChanged();
        }
    }    
   
    /// <remarks/>
    public string metrologist {
        get {
            return this.metrologistField;
        }
        set {
	        if (value == this.metrologistField) return;
	        this.metrologistField = value;
	        OnPropertyChanged();
        }
    }
    
    /// <remarks/>
    public recInfoMeans means {
        get {
            return this.meansField;
        }
        set {
	        if (value == this.meansField) return;
	        this.meansField = value;
	        OnPropertyChanged();
        }
    }
    
    [Required (ErrorMessage ="Поле \"Условия проведения поверки\" не заполнено.", AllowEmptyStrings = false)]
    /// <remarks/>
    public recInfoConditions conditions {
        get {
            return this.conditionsField;
        }
        set {
	        if (value == this.conditionsField) return;
	        this.conditionsField = value;
	        OnPropertyChanged();
        }
    }
    
    /// <remarks/>
    public string structure {
        get {
            return this.structureField;
        }
        set {
	        if (value == this.structureField) return;
	        this.structureField = value;
	        OnPropertyChanged();
        }
    }
    
    public bool IsBriefProcedure
    {
    	get
		{
    		return this.isBriefProcedureField;
        }
        set
        {            
    		if (value == this.isBriefProcedureField) return;
			this.isBriefProcedureField = value;
			OnPropertyChanged();
        }
    }    
    
    /// <remarks/>
    public recInfoBrief_procedure brief_procedure {
        get {
            return this.brief_procedureField;
        }
        set {
	        if (value == this.brief_procedureField) return;
	        this.brief_procedureField = value;
	        OnPropertyChanged();
        }
    }
    
    /// <remarks/>
    public string additional_info {
        get {
            return this.additional_infoField;
        }
        set {
	        if (value == this.additional_infoField) return;
	        this.additional_infoField = value;
	        OnPropertyChanged();
        }
    }
    
    public bool IsProtocol
    {
	    get
	    {
		    return this.isProtocolField;
	    }
	    set
	    {            
		    if (value == this.isProtocolField) return;
		    this.isProtocolField = value;
		    OnPropertyChanged();
	    }
    }    
    
    
    /// <remarks/>
    public recInfoProtocol protocol {
        get {
            return this.protocolField;
        }
        set {
	        if (value == this.protocolField) return;
	        this.protocolField = value;
	        OnPropertyChanged();
        }
    }
}



public enum MIType
{
	/// <remarks/>
    [Description("etaMI")]    
    etaMI,
    
    /// <remarks/>
    [Description("singleMI")]    
    singleMI  

}

/// <remarks/>
[System.SerializableAttribute()]
public partial class recInfoMiInfo : INotifyPropertyChanged, INotifyDataErrorInfo
{
	private recInfoMiInfoEtaMI etaMIField;
	private recInfoMiInfoSingleMI singleMIField;
	private MIType miTypeField;
	
	public recInfoMiInfo()
	{
		etaMIField = new recInfoMiInfoEtaMI();
		singleMIField = new recInfoMiInfoSingleMI();
		miTypeField = MIType.etaMI;
		etaMIField.PropertyChanged += OnPropertyChangeEventHandler;
		singleMIField.PropertyChanged += OnPropertyChangeEventHandler;
	}

	public void PostCreateLogic()
	{
		etaMIField.PropertyChanged += OnPropertyChangeEventHandler;
		etaMIField.PostCreateLogic();
		singleMIField.PropertyChanged += OnPropertyChangeEventHandler;
	}
	
	private void OnPropertyChangeEventHandler(object sender, PropertyChangedEventArgs e)
	{
		//if (PropertyChanged != null) PropertyChanged.Invoke(this, new PropertyChangedEventArgs(null));
		if (PropertyChanged != null) PropertyChanged.Invoke(this, new PropertyChangedEventArgs(e.PropertyName));
	}

	#region
	public event PropertyChangedEventHandler PropertyChanged;
	
	protected void OnPropertyChanged([CallerMemberName] string propertyName = "")
	{
		if (PropertyChanged != null) PropertyChanged.Invoke(this, new PropertyChangedEventArgs(propertyName));
		//PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
		if (_isValidateField) Validate();
	}
	#endregion
    
	#region INotifyDataErrorInfo implementation

	private readonly Dictionary<string, List<string>> _errorsByPropertyName = new Dictionary<string, List<string>>();

	public event EventHandler<DataErrorsChangedEventArgs> ErrorsChanged;

	public IEnumerable GetErrors(string propertyName)
	{
		return _errorsByPropertyName.ContainsKey(propertyName) ? _errorsByPropertyName[propertyName] : null;
	}

	public bool HasErrors
	{
		get { return _errorsByPropertyName.Any(); }
	}

	private void OnErrorChanged(string propertyName)
	{
		if (ErrorsChanged != null) ErrorsChanged.Invoke(this, new DataErrorsChangedEventArgs(propertyName));
	}

	private void AddError(string propertyName, string error)
	{
		if (!_errorsByPropertyName.ContainsKey(propertyName))
			_errorsByPropertyName[propertyName] = new List<string>();
		if (!_errorsByPropertyName[propertyName].Contains(error))
		{
			_errorsByPropertyName[propertyName].Add(error);
			OnErrorChanged(propertyName);
		}
	}

	private void ClearErrors(string propertyName)
	{
		if (_errorsByPropertyName.ContainsKey(propertyName))
		{
			_errorsByPropertyName.Remove(propertyName);
			OnErrorChanged(propertyName);
		}
	}

	public void ClearAllErrors()
	{
		List<string> properties = new List<string>();
		foreach (KeyValuePair<string, List<string>> error in this._errorsByPropertyName)
			properties.Add(error.Key);
		this._errorsByPropertyName.Clear();
		foreach (string property in properties)
			this.OnPropertyChanged(property);
	}

	public void Validate()
	{
		/*ClearErrors("mitypeNumber");
		if (string.IsNullOrWhiteSpace(mitypeNumberField))
			AddError("mitypeNumber", "Поле \"Номер в Госреестре утвержденного типа СИ\" не заполнено.");

		ClearErrors("modification");
		if (string.IsNullOrWhiteSpace(modificationField))
			AddError("modification", "Поле \"Модификация СИ\" не заполнено.");

		ClearErrors("manufactureNum");
		if (string.IsNullOrWhiteSpace(manufactureNumField))
			AddError("manufactureNum", "Поле \"Заводской номер СИ\" не заполнено.");

		ClearErrors("manufactureYear");
		if (string.IsNullOrWhiteSpace(manufactureYearField))
			AddError("manufactureYear", "Поле \"Год выпуска СИ\" не заполнено.");
		if ((manufactureYearInteger < 1950) || (manufactureYearInteger > DateTime.Now.Year))
			AddError("manufactureYear", $"Поле \"Год выпуска СИ\" должен быть в пределах 1950-{DateTime.Now.Year}");
		*/
		if (miTypeField == MIType.etaMI) 
		{
			etaMIField.IsValidate = true;
			singleMIField.IsValidate = false;
		}
		else
		{
			singleMIField.IsValidate = true;
			etaMIField.IsValidate = false;
		}
	}

	[XmlIgnore] private bool _isValidateField;

	[XmlIgnore]
	public bool IsValidate
	{
		get { return _isValidateField; }
		set
		{
			if (value == this._isValidateField) return;
			this._isValidateField = value;
			if (!_isValidateField)
			{
				ClearAllErrors();
				etaMIField.IsValidate = false;
				singleMIField.IsValidate = false;
			}
			OnPropertyChanged();
		}
	}

	#endregion
	
	
	public MIType Type
    {
    	get {
            return this.miTypeField;
        }
        set {            
    		if (value == this.miTypeField) return;
			this.miTypeField = value;
			OnPropertyChanged();
        }
    }
	
	
	/// <remarks/>
    public recInfoMiInfoEtaMI etaMI
    {
        get {
            return this.etaMIField;
        }
        set {
	        if (value == this.etaMIField) return;
	        this.etaMIField = value;
	        OnPropertyChanged();
        }
    }
    
    /// <remarks/>
    public recInfoMiInfoSingleMI singleMI
    {
        get {
            return this.singleMIField;
        }
        set {
	        if (value == this.singleMIField) return;
	        this.singleMIField = value;
	        OnPropertyChanged();
        }
    }
	
}


public enum etaMIType
{
	/// <remarks/>
    [Description("primaryRec")]    
    primaryRec,
    
    /// <remarks/>
    [Description("regNumber")]    
    regNumber  
}


/// <remarks/>
[System.SerializableAttribute()]
public partial class recInfoMiInfoEtaMI : INotifyPropertyChanged
{
    
    private recInfoMiInfoEtaMIPrimaryRec primaryRecField;
    private recInfoMiInfoEtaMIRegNumber regNumberField; 
    //private string regNumberField;
    private etaMIType typeField;
    
    public recInfoMiInfoEtaMI()
    {
    	primaryRecField = new recInfoMiInfoEtaMIPrimaryRec();
    	regNumberField = new recInfoMiInfoEtaMIRegNumber();
    	typeField = etaMIType.primaryRec;
        
        primaryRec.PropertyChanged+= OnPropertyChangeEventHandler;
        regNumberField.PropertyChanged+= OnPropertyChangeEventHandler;

        _isValidateField = false;
    }

    public void PostCreateLogic()
    {
	    primaryRec.PropertyChanged+= OnPropertyChangeEventHandler;
	    primaryRec.PostCreateLogic();
	    regNumberField.PropertyChanged+= OnPropertyChangeEventHandler;
    }

    private void OnPropertyChangeEventHandler(object sender, PropertyChangedEventArgs e)
    {
	    //if (PropertyChanged != null) PropertyChanged.Invoke(this, new PropertyChangedEventArgs(null));
	    if (PropertyChanged != null) PropertyChanged.Invoke(this, new PropertyChangedEventArgs(e.PropertyName));
    }


    #region
	public event PropertyChangedEventHandler PropertyChanged;
	
	protected void OnPropertyChanged([CallerMemberName] string propertyName = "")
	{
		if (PropertyChanged != null) PropertyChanged.Invoke(this, new PropertyChangedEventArgs(propertyName));
		if (_isValidateField) Validate();
		//PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
	}
	#endregion
    
	#region INotifyDataErrorInfo implementation

	private readonly Dictionary<string, List<string>> _errorsByPropertyName = new Dictionary<string, List<string>>();

	public event EventHandler<DataErrorsChangedEventArgs> ErrorsChanged;

	public IEnumerable GetErrors(string propertyName)
	{
		return _errorsByPropertyName.ContainsKey(propertyName) ? _errorsByPropertyName[propertyName] : null;
	}

	public bool HasErrors
	{
		get { return _errorsByPropertyName.Any(); }
	}

	private void OnErrorChanged(string propertyName)
	{
		if (ErrorsChanged != null) ErrorsChanged.Invoke(this, new DataErrorsChangedEventArgs(propertyName));
	}

	private void AddError(string propertyName, string error)
	{
		if (!_errorsByPropertyName.ContainsKey(propertyName))
			_errorsByPropertyName[propertyName] = new List<string>();
		if (!_errorsByPropertyName[propertyName].Contains(error))
		{
			_errorsByPropertyName[propertyName].Add(error);
			OnErrorChanged(propertyName);
		}
	}

	private void ClearErrors(string propertyName)
	{
		if (_errorsByPropertyName.ContainsKey(propertyName))
		{
			_errorsByPropertyName.Remove(propertyName);
			OnErrorChanged(propertyName);
		}
	}

	public void ClearAllErrors()
	{
		List<string> properties = new List<string>();
		foreach (KeyValuePair<string, List<string>> error in this._errorsByPropertyName)
			properties.Add(error.Key);
		this._errorsByPropertyName.Clear();
		foreach (string property in properties)
			this.OnPropertyChanged(property);
	}


	public void Validate()
	{
		/*ClearErrors("mitypeNumber");
		if (string.IsNullOrWhiteSpace(mitypeNumberField))
			AddError("mitypeNumber", "Поле \"Номер в Госреестре утвержденного типа СИ\" не заполнено.");

		ClearErrors("modification");
		if (string.IsNullOrWhiteSpace(modificationField))
			AddError("modification", "Поле \"Модификация СИ\" не заполнено.");

		ClearErrors("manufactureNum");
		if (string.IsNullOrWhiteSpace(manufactureNumField))
			AddError("manufactureNum", "Поле \"Заводской номер СИ\" не заполнено.");

		ClearErrors("manufactureYear");
		if (string.IsNullOrWhiteSpace(manufactureYearField))
			AddError("manufactureYear", "Поле \"Год выпуска СИ\" не заполнено.");
		if ((manufactureYearInteger < 1950) || (manufactureYearInteger > DateTime.Now.Year))
			AddError("manufactureYear", $"Поле \"Год выпуска СИ\" должен быть в пределах 1950-{DateTime.Now.Year}");
		*/
		
		if (typeField == etaMIType.primaryRec) 
		{
			primaryRecField.IsValidate = true;
			regNumberField.IsValidate = false;
			//regNumberField.ClearAllErrors();
		}
		else
		{
			regNumberField.IsValidate = true;
			primaryRecField.IsValidate = false;
		}
		
	}

	[XmlIgnore] private bool _isValidateField;

	[XmlIgnore]
	public bool IsValidate
	{
		get { return _isValidateField; }
		set
		{
			if (value == this._isValidateField) return;
			this._isValidateField = value;
			if (!_isValidateField)
			{
				ClearAllErrors();
				primaryRec.IsValidate = false;
				regNumberField.IsValidate = false;
			}
			OnPropertyChanged();
		}
	}

	#endregion
    
    public etaMIType Type
    {
    	get {
    		//if (typeField == etaMIType.primaryRec) primaryRecField.IsValidate = true; 
    		//else primaryRecField.IsValidate = false; 
            return this.typeField;
        }
        set {        
    		if (value == this.typeField) return;
    		//if (value == etaMIType.primaryRec) primaryRecField.IsValidate = true; 
    		//else primaryRecField.IsValidate = false;    		
    		this.typeField = value;
			OnPropertyChanged();
        }
    }
    
	
    
    
    /// <remarks/>
    public recInfoMiInfoEtaMIPrimaryRec primaryRec
    {
        get {
            return this.primaryRecField;
        }
        set {
	        if (value == this.primaryRecField) return;
	        this.primaryRecField = value;
	        OnPropertyChanged();
        }
    }
    
    /// <remarks/>
    public recInfoMiInfoEtaMIRegNumber regNumber
    {
        get {
            return this.regNumberField;
        }
        set {
	        if (value == this.regNumberField) return;
	        this.regNumberField = value;
	        OnPropertyChanged();
        }
    }    
  
}


 
public enum PSType
{
	/*/// <remarks/>
    [Description("no type")]    
    none,
	*/
	/// <remarks/>
    [Description("gps")]    
    gps,
    
    /// <remarks/>
    [Description("lps")]    
    lps,    
   
}

/// <remarks/>
[System.SerializableAttribute()]
public partial class recInfoMiInfoEtaMIPrimaryRec : INotifyPropertyChanged, INotifyDataErrorInfo //,IDataErrorInfo
{
	#region

	public event PropertyChangedEventHandler PropertyChanged;

	protected void OnPropertyChanged([CallerMemberName] string propertyName = "")
	{
		if (PropertyChanged != null) PropertyChanged.Invoke(this, new PropertyChangedEventArgs(propertyName));
		//PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
		if (_isValidateField) Validate();
	}

	#endregion

	private string mitypeNumberField;

	private string modificationField;

	private string manufactureNumField;

	private string manufactureYearField;

	private bool isOwnerField;

	private bool isPSField;

	//private PSType typeField;

	private recInfoMiInfoEtaMIPrimaryRecPs psField;

	private recInfoMiInfoEtaMIPrimaryRecMP mpField;

	#region IDataErrorInfo implementation

	/*public string this[string columnName] {
		get {
			string res = null;			
			//if (!IsValidate) return res;
			if (columnName == "modification")
			{
				if (string.IsNullOrWhiteSpace(modification))
				    res = "Поле \"Модификация СИ\" не заполнено.";
				return res;
			}
			return string.Empty;
		}
	}
	public string Error {
		get {
			return null;
		}
	}*/

	#endregion

	#region INotifyDataErrorInfo implementation

	private readonly Dictionary<string, List<string>> _errorsByPropertyName = new Dictionary<string, List<string>>();

	public event EventHandler<DataErrorsChangedEventArgs> ErrorsChanged;

	public IEnumerable GetErrors(string propertyName)
	{
		return _errorsByPropertyName.ContainsKey(propertyName) ? _errorsByPropertyName[propertyName] : null;
	}

	public bool HasErrors
	{
		get { return _errorsByPropertyName.Any(); }
	}

	private void OnErrorChanged(string propertyName)
	{
		if (ErrorsChanged != null) ErrorsChanged.Invoke(this, new DataErrorsChangedEventArgs(propertyName));
	}

	private void AddError(string propertyName, string error)
	{
		if (!_errorsByPropertyName.ContainsKey(propertyName))
			_errorsByPropertyName[propertyName] = new List<string>();
		if (!_errorsByPropertyName[propertyName].Contains(error))
		{
			_errorsByPropertyName[propertyName].Add(error);
			OnErrorChanged(propertyName);
		}
	}

	private void ClearErrors(string propertyName)
	{
		if (_errorsByPropertyName.ContainsKey(propertyName))
		{
			_errorsByPropertyName.Remove(propertyName);
			OnErrorChanged(propertyName);
		}
	}

	public void ClearAllErrors()
	{
		List<string> properties = new List<string>();
		foreach (KeyValuePair<string, List<string>> error in this._errorsByPropertyName)
			properties.Add(error.Key);
		this._errorsByPropertyName.Clear();
		foreach (string property in properties)
			this.OnPropertyChanged(property);
	}


	public void Validate()
	{
		ClearErrors("mitypeNumber");
		if (string.IsNullOrWhiteSpace(mitypeNumberField))
			AddError("mitypeNumber", "Поле \"Номер в Госреестре утвержденного типа СИ\" не заполнено.");

		ClearErrors("modification");
		if (string.IsNullOrWhiteSpace(modificationField))
			AddError("modification", "Поле \"Модификация СИ\" не заполнено.");

		ClearErrors("manufactureNum");
		if (string.IsNullOrWhiteSpace(manufactureNumField))
			AddError("manufactureNum", "Поле \"Заводской номер СИ\" не заполнено.");

		ClearErrors("manufactureYear");
		if (string.IsNullOrWhiteSpace(manufactureYearField))
			AddError("manufactureYear", "Поле \"Год выпуска СИ\" не заполнено.");
		if ((manufactureYearInteger < 1950) || (manufactureYearInteger > DateTime.Now.Year))
			AddError("manufactureYear", $"Поле \"Год выпуска СИ\" должен быть в пределах 1950-{DateTime.Now.Year}");
		
		if (IsPS) 
		{
			psField.IsValidate = true;
			mpField.IsValidate = false;
			//mpField.ClearAllErrors();
		}
		else
		{
			mpField.IsValidate = true;
			psField.IsValidate = false;
			//psField.ClearAllErrors();
		}
		
	}

	[XmlIgnore] private bool _isValidateField;

	[XmlIgnore]
	public bool IsValidate
	{
		get { return _isValidateField; }
		set
		{
			if (value == this._isValidateField) return;
			this._isValidateField = value;
			if (!_isValidateField)
			{
				ClearAllErrors();
				psField.IsValidate = false;
				mpField.IsValidate = false;
			}
			OnPropertyChanged();
		}
	}

	#endregion



	public recInfoMiInfoEtaMIPrimaryRec()
	{
		isPSField = true;
		//typeField = PSType.gps;
		psField = new recInfoMiInfoEtaMIPrimaryRecPs();
		mpField = new recInfoMiInfoEtaMIPrimaryRecMP();
		_isValidateField = false;
		//IsValidate = false;

		psField.PropertyChanged += OnPropertyChangeEventHandler;
		mpField.PropertyChanged += OnPropertyChangeEventHandler;
	}

	public void PostCreateLogic()
	{
		psField.PropertyChanged += OnPropertyChangeEventHandler;
		mpField.PropertyChanged += OnPropertyChangeEventHandler;
	}


	private void OnPropertyChangeEventHandler(object sender, PropertyChangedEventArgs e)
	{
		//if (PropertyChanged != null) PropertyChanged.Invoke(this, new PropertyChangedEventArgs(null));
		if (PropertyChanged != null) PropertyChanged.Invoke(this, new PropertyChangedEventArgs(e.PropertyName));
	}



	[Required(ErrorMessage = "Поле \"Номер в Госреестре утвержденного типа СИ\" не заполнено.",
		AllowEmptyStrings = false)]
	public string mitypeNumber
	{
		get
		{
			//if (mitypeNumberField != null) mitypeNumberField = mitypeNumberField.Trim();
			return this.mitypeNumberField;
		}
		set
		{
			if (value == this.mitypeNumberField) return;
			this.mitypeNumberField = value;
			OnPropertyChanged();
		}
	}

	[Required(ErrorMessage = "Поле \"Модификация СИ\" не заполнено.", AllowEmptyStrings = false)]
	public string modification
	{

		get { return this.modificationField; }
		set
		{
			if (value == this.modificationField) return;
			this.modificationField = value;
			if (_isValidateField) Validate();
			OnPropertyChanged();
		}
	}

	[Required(ErrorMessage = "Поле \"Заводской номер СИ\" не заполнено.", AllowEmptyStrings = false)]
	public string manufactureNum
	{
		get { return this.manufactureNumField; }
		set
		{
			if (value == this.manufactureNumField) return;
			this.manufactureNumField = value;
			OnPropertyChanged();
		}
	}

	[Required(ErrorMessage = "Поле \"Год выпуска СИ\" не заполнено.", AllowEmptyStrings = false)]
	//[Year]
	[Range(typeof(DateTime), "1/2/2004", "3/4/2004",
		ErrorMessage = "Value for {0} must be between {1} and {2}")]
	public string manufactureYear
	{
		get { return this.manufactureYearField; }
		set
		{
			if (value == this.manufactureYearField) return;
			this.manufactureYearField = value;
			OnPropertyChanged();
		}
	}

	private int manufactureYearInteger
	{
		get
		{
			int result;
			if (int.TryParse(manufactureYearField, out result))
			{
				return result;
			}
			else return -1;
		}
	}

	[Required (ErrorMessage ="Поле \"Поверитель является владельцем СИ, применяемого в качестве эталона\" не заполнено.", AllowEmptyStrings = false)] 
   public bool isOwner {
        get {
            return this.isOwnerField;
        }
        set {            
    		if (value == this.isOwnerField) return;
			this.isOwnerField= value;
			OnPropertyChanged();     	
        }
    }

   
   public bool IsPS {
        get {
            return this.isPSField;
        }
        set {            
    		if (value == this.isPSField) return;
			this.isPSField = value;
			//if (!this.isPSField) typeField = PSType.mp;			
			OnPropertyChanged();  		
        }
    }


   public recInfoMiInfoEtaMIPrimaryRecPs ps
    {
    	get {
            return this.psField;
        }
        set {            
    		if (value == this.psField) return;
			this.psField = value;
			OnPropertyChanged();  		
    }
   	}   
     	
    public recInfoMiInfoEtaMIPrimaryRecMP mp
    {
    	get {
    		return this.mpField;
        }
        set {            
    		if (value == this.mpField) return;
			this.mpField = value;
			OnPropertyChanged();    		
    		
    }
    }
   
}

[Serializable]
public partial class recInfoMiInfoEtaMIRegNumber : INotifyPropertyChanged, INotifyDataErrorInfo
{
	#region
	public event PropertyChangedEventHandler PropertyChanged;
	
	protected void OnPropertyChanged([CallerMemberName] string propertyName = "")
	{
		if (PropertyChanged != null) PropertyChanged.Invoke(this, new PropertyChangedEventArgs(propertyName));
		//PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
		if (_isValidateField) Validate();
	}
	#endregion
	
	
	#region INotifyDataErrorInfo implementation

	private readonly Dictionary<string, List<string>> _errorsByPropertyName = new Dictionary<string, List<string>>();

	public event EventHandler<DataErrorsChangedEventArgs> ErrorsChanged;

	public IEnumerable GetErrors(string propertyName)
	{
		return _errorsByPropertyName.ContainsKey(propertyName) ? _errorsByPropertyName[propertyName] : null;
	}

	public bool HasErrors
	{
		get { return _errorsByPropertyName.Any(); }
	}

	private void OnErrorChanged(string propertyName)
	{
		if (ErrorsChanged != null) ErrorsChanged.Invoke(this, new DataErrorsChangedEventArgs(propertyName));
	}

	private void AddError(string propertyName, string error)
	{
		if (!_errorsByPropertyName.ContainsKey(propertyName))
			_errorsByPropertyName[propertyName] = new List<string>();
		if (!_errorsByPropertyName[propertyName].Contains(error))
		{
			_errorsByPropertyName[propertyName].Add(error);
			OnErrorChanged(propertyName);
		}
	}

	private void ClearErrors(string propertyName)
	{
		if (_errorsByPropertyName.ContainsKey(propertyName))
		{
			_errorsByPropertyName.Remove(propertyName);
			OnErrorChanged(propertyName);
		}
	}

	public void ClearAllErrors()
	{
		List<string> properties = new List<string>();
		foreach (KeyValuePair<string, List<string>> error in this._errorsByPropertyName)
			properties.Add(error.Key);
		this._errorsByPropertyName.Clear();
		foreach (string property in properties)
			this.OnPropertyChanged(property);
	}


	public void Validate()
	{
		ClearErrors("regNumber");
		if (string.IsNullOrWhiteSpace(regNumberField))
			AddError("regNumber", "Поле \"Номер СИ по Перечню СИ, применяемых в качестве эталонов\" не заполнено.");
	}

	[XmlIgnore] private bool _isValidateField;

	[XmlIgnore]
	public bool IsValidate
	{
		get { return _isValidateField; }
		set
		{
			if (value == this._isValidateField) return;
			this._isValidateField = value;
			if (!_isValidateField) ClearAllErrors();//Validate();
			OnPropertyChanged();
		}
	}

	#endregion

	public recInfoMiInfoEtaMIRegNumber()
	{
		_isValidateField = false;
	}


	private string regNumberField;
	
	[Required (ErrorMessage ="Поле \"Номер СИ по Перечню СИ, применяемых в качестве эталонов\" не заполнено.", AllowEmptyStrings = false)] 	
    public string regNumber
    {
       get {
            return this.regNumberField;
        }
        set {            
    		if (value == this.regNumberField) return;
			this.regNumberField = value;
			OnPropertyChanged();  
    		}
    }    	
	
}

/// <remarks/>
[System.SerializableAttribute()]
public enum rankEnum
{
	/// <remarks/>
    [Description("0Р")]
    [System.Xml.Serialization.XmlEnumAttribute("0Р")]
    Item1,
    
    /// <remarks/>
    [Description("1Р")]
    [System.Xml.Serialization.XmlEnumAttribute("1Р")]
    Item2,
    
    /// <remarks/>
    [Description("2Р")]
    [System.Xml.Serialization.XmlEnumAttribute("2Р")]
    Item3,
    
    /// <remarks/>
    [Description("3Р")]
    [System.Xml.Serialization.XmlEnumAttribute("3Р")]
    Item4,	
	
     /// <remarks/>
    [Description("4Р")]
    [System.Xml.Serialization.XmlEnumAttribute("4Р")]
    Item5,	
    
    /// <remarks/>
    [Description("5Р")]
    [System.Xml.Serialization.XmlEnumAttribute("5Р")]
    Item6,
          
    /// <remarks/>
    [Description("РЭ")]
    [System.Xml.Serialization.XmlEnumAttribute("РЭ")]
    Item7,
    
    /// <remarks/>
    [Description("ВЭ")]
    [System.Xml.Serialization.XmlEnumAttribute("ВЭ")]
    Item8,
    
    /// <remarks/>
    [Description("СИ")]
    [System.Xml.Serialization.XmlEnumAttribute("СИ")]
    Item9  
    
}

/// <remarks/>
[System.SerializableAttribute()]
public partial class recInfoMiInfoEtaMIPrimaryRecPs : INotifyPropertyChanged, INotifyDataErrorInfo
{
    
	#region
	public event PropertyChangedEventHandler PropertyChanged;
	
	protected void OnPropertyChanged([CallerMemberName] string propertyName = "")
	{
		if (PropertyChanged != null) PropertyChanged.Invoke(this, new PropertyChangedEventArgs(propertyName));
		//PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
		if (_isValidateField) Validate();
	}
	#endregion
	
	private PSType typeField;
	
    private string titleField;
    
    private string npeNumberField;
    
    private rankEnum rankField = default (rankEnum);    
    
    #region INotifyDataErrorInfo implementation

	private readonly Dictionary<string, List<string>> _errorsByPropertyName = new Dictionary<string, List<string>>();

	public event EventHandler<DataErrorsChangedEventArgs> ErrorsChanged;

	public IEnumerable GetErrors(string propertyName)
	{
		return _errorsByPropertyName.ContainsKey(propertyName) ? _errorsByPropertyName[propertyName] : null;
	}

	public bool HasErrors
	{
		get { return _errorsByPropertyName.Any(); }
	}

	private void OnErrorChanged(string propertyName)
	{
		if (ErrorsChanged != null) ErrorsChanged.Invoke(this, new DataErrorsChangedEventArgs(propertyName));
	}

	private void AddError(string propertyName, string error)
	{
		if (!_errorsByPropertyName.ContainsKey(propertyName))
			_errorsByPropertyName[propertyName] = new List<string>();
		if (!_errorsByPropertyName[propertyName].Contains(error))
		{
			_errorsByPropertyName[propertyName].Add(error);
			OnErrorChanged(propertyName);
		}
	}

	private void ClearErrors(string propertyName)
	{
		if (_errorsByPropertyName.ContainsKey(propertyName))
		{
			_errorsByPropertyName.Remove(propertyName);
			OnErrorChanged(propertyName);
		}
	}

	public void ClearAllErrors()
	{
		List<string> properties = new List<string>();
		foreach (KeyValuePair<string, List<string>> error in this._errorsByPropertyName)
			properties.Add(error.Key);
		this._errorsByPropertyName.Clear();
		foreach (string property in properties)
			this.OnPropertyChanged(property);
	}


	public void Validate()
	{
		ClearErrors("title");
		if (string.IsNullOrWhiteSpace(titleField))
			AddError("title", "Поле \"Наименование Государственной (локальной) поверочной схемы\" не заполнено.");

		ClearErrors("npeNumber");
		if (string.IsNullOrWhiteSpace(npeNumberField))
			AddError("npeNumber", "Поле \"Регистрационный номер ГПЭ, к которому прослеживается СИ, применяемое в качестве эталона\" не заполнено.");
	}

	[XmlIgnore] private bool _isValidateField;

	[XmlIgnore]
	public bool IsValidate
	{
		get { return _isValidateField; }
		set
		{
			if (value == this._isValidateField) return;
			this._isValidateField = value;
			if (!_isValidateField) ClearAllErrors();
			OnPropertyChanged();
		}
	}

	#endregion
    
    
    public recInfoMiInfoEtaMIPrimaryRecPs()
    {
    	typeField= PSType.gps;
        _isValidateField = false;
    }
    
    [Required (ErrorMessage ="Поле \"Наименование поверочной схемы\" не заполнено.", AllowEmptyStrings = false)]
    public string title {
        get {
            return this.titleField;
        }
        set
        {
	        if (value == this.titleField) return;
	        this.titleField = value;
	        OnPropertyChanged();
        }
    }
    
    [Required (ErrorMessage ="Поле \"Регистрационный номер ГПЭ, к которому прослеживается СИ, применяемое в качестве эталона\" не заполнено.", AllowEmptyStrings = false)]
    public string npeNumber {
        get {
            return this.npeNumberField;
        }
        set {
	        if (value == this.npeNumberField) return;
	        this.npeNumberField = value;
	        OnPropertyChanged();
        }
    }
    
    [Required (ErrorMessage ="Поле \"Разряд в поверочной схеме\" не заполнено.", AllowEmptyStrings = false)]
    public rankEnum rank {
        get {
            return this.rankField;
        }
        set 
        {
	        if (value == this.rankField) return;
			this.rankField = value;
			OnPropertyChanged();
        }
    }
    
     public PSType Type {
        get {
            return this.typeField;
        }
        set {
	        if (value == this.typeField) return;
			this.typeField = value;
			OnPropertyChanged();           
        }
    }
}


/// <remarks/>
[System.SerializableAttribute()]
public partial class recInfoMiInfoEtaMIPrimaryRecMP :  INotifyPropertyChanged, INotifyDataErrorInfo
{
    	
	#region
	public event PropertyChangedEventHandler PropertyChanged;
	
	protected void OnPropertyChanged([CallerMemberName] string propertyName = "")
	{
		if (PropertyChanged != null) PropertyChanged.Invoke(this, new PropertyChangedEventArgs(propertyName));
		//PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
		if (_isValidateField) Validate();
	}
	#endregion

	#region INotifyDataErrorInfo implementation

	private readonly Dictionary<string, List<string>> _errorsByPropertyName = new Dictionary<string, List<string>>();

	public event EventHandler<DataErrorsChangedEventArgs> ErrorsChanged;

	public IEnumerable GetErrors(string propertyName)
	{
		return _errorsByPropertyName.ContainsKey(propertyName) ? _errorsByPropertyName[propertyName] : null;
	}

	public bool HasErrors
	{
		get { return _errorsByPropertyName.Any(); }
	}

	private void OnErrorChanged(string propertyName)
	{
		if (ErrorsChanged != null) ErrorsChanged.Invoke(this, new DataErrorsChangedEventArgs(propertyName));
	}

	private void AddError(string propertyName, string error)
	{
		if (!_errorsByPropertyName.ContainsKey(propertyName))
			_errorsByPropertyName[propertyName] = new List<string>();
		if (!_errorsByPropertyName[propertyName].Contains(error))
		{
			_errorsByPropertyName[propertyName].Add(error);
			OnErrorChanged(propertyName);
		}
	}

	private void ClearErrors(string propertyName)
	{
		if (_errorsByPropertyName.ContainsKey(propertyName))
		{
			_errorsByPropertyName.Remove(propertyName);
			OnErrorChanged(propertyName);
		}
	}

	public void ClearAllErrors()
	{
		List<string> properties = new List<string>();
		foreach (KeyValuePair<string, List<string>> error in this._errorsByPropertyName)
			properties.Add(error.Key);
		this._errorsByPropertyName.Clear();
		foreach (string property in properties)
			this.OnPropertyChanged(property);
	}


	public void Validate()
	{
		ClearErrors("title");
		if (string.IsNullOrWhiteSpace(titleField))
			AddError("title", "Поле \"Наименования методик поверки\" не заполнено.");
	}

	[XmlIgnore] private bool _isValidateField;

	[XmlIgnore]
	public bool IsValidate
	{
		get { return _isValidateField; }
		set
		{
			if (value == this._isValidateField) return;
			this._isValidateField = value;
			if (!_isValidateField) ClearAllErrors();
			OnPropertyChanged();
		}
	}

	#endregion
	
	public recInfoMiInfoEtaMIPrimaryRecMP()
	{
		_isValidateField = false;
	}

	
    private string titleField;
    
    /// <remarks/>
    [Required (ErrorMessage ="Поле \"Наименования методик поверки\" не заполнено.", AllowEmptyStrings = false)]
    public string title {
        get {
            return this.titleField;
        }
        set {
	        if (value == this.titleField) return;
	        this.titleField = value;
	        OnPropertyChanged();
        }
    }
}


	/// <remarks/>
	[System.SerializableAttribute()]
	public partial class recInfoMiInfoSingleMI : INotifyPropertyChanged, INotifyDataErrorInfo
	{

	private string mitypeNumberField;
    
    private string crtmitypeTitleField;
    
    private string milmitypeTitleField;   
      	
    private string manufactureNumField;
    
    private string inventoryNumField;
    
    private Item1ChoiceType type1Field;
    
    private Item2ChoiceType type2Field;
    
    private string manufactureYearField;
    
    private string modificationField;
    
   	#region
	public event PropertyChangedEventHandler PropertyChanged;
	
	protected void OnPropertyChanged([CallerMemberName] string propertyName = "")
	{
		if (PropertyChanged != null) PropertyChanged.Invoke(this, new PropertyChangedEventArgs(propertyName));
		//PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
		if (_isValidateField) Validate();
	}
	#endregion

	public recInfoMiInfoSingleMI()
	{
		_isValidateField = false;
	}

	#region INotifyDataErrorInfo implementation

	private readonly Dictionary<string, List<string>> _errorsByPropertyName = new Dictionary<string, List<string>>();

	public event EventHandler<DataErrorsChangedEventArgs> ErrorsChanged;

	public IEnumerable GetErrors(string propertyName)
	{
		return _errorsByPropertyName.ContainsKey(propertyName) ? _errorsByPropertyName[propertyName] : null;
	}

	public bool HasErrors
	{
		get { return _errorsByPropertyName.Any(); }
	}

	private void OnErrorChanged(string propertyName)
	{
		if (ErrorsChanged != null) ErrorsChanged.Invoke(this, new DataErrorsChangedEventArgs(propertyName));
	}

	private void AddError(string propertyName, string error)
	{
		if (!_errorsByPropertyName.ContainsKey(propertyName))
			_errorsByPropertyName[propertyName] = new List<string>();
		if (!_errorsByPropertyName[propertyName].Contains(error))
		{
			_errorsByPropertyName[propertyName].Add(error);
			OnErrorChanged(propertyName);
		}
	}

	private void ClearErrors(string propertyName)
	{
		if (_errorsByPropertyName.ContainsKey(propertyName))
		{
			_errorsByPropertyName.Remove(propertyName);
			OnErrorChanged(propertyName);
		}
	}

	public void ClearAllErrors()
	{
		List<string> properties = new List<string>();
		foreach (KeyValuePair<string, List<string>> error in this._errorsByPropertyName)
			properties.Add(error.Key);
		this._errorsByPropertyName.Clear();
		foreach (string property in properties)
			this.OnPropertyChanged(property);
	}


	public void Validate()
	{
		ClearErrors("modification");
		if (string.IsNullOrWhiteSpace(modificationField))
			AddError("modification", "Поле \"Модификация СИ\" не заполнено.");
		
	/*if ()
		
	private string mitypeNumberField;
    
	private string crtmitypeTitleField;
    
	private string milmitypeTitleField;   
      	
	private string manufactureNumField;
    
	private string inventoryNumField;
    
	private Item1ChoiceType type1Field;
    
	private Item2ChoiceType type2Field;
    
	private string manufactureYearField;
    
	private string modificationField;
		*/
    
	switch (type1Field)
	{
		case  Item1ChoiceType.mitypeNumber:
			ClearErrors("mitypeNumber");
			if (string.IsNullOrWhiteSpace(mitypeNumberField))
				AddError("mitypeNumber", "Поле \"Номер в Госреестре утвержденного типа СИ\" не заполнено.");
			ClearErrors("crtmitypeTitle");
			ClearErrors("milmitypeTitle");
			break;
		case  Item1ChoiceType.crtmitypeTitle:
			ClearErrors("crtmitypeTitle");
			if (string.IsNullOrWhiteSpace(crtmitypeTitleField))
				AddError("crtmitypeTitle", "Поле \"Метрологическая аттестация: наименование СИ\" не заполнено.");
			ClearErrors("mitypeNumber");
			ClearErrors("milmitypeTitle");
			break;
		case  Item1ChoiceType.milmitypeTitle:
			ClearErrors("milmitypeTitle");
			if (string.IsNullOrWhiteSpace(milmitypeTitleField))
				AddError("milmitypeTitle", "Поле \"СИ специального назначения: наименование СИ\" не заполнено.");
			ClearErrors("mitypeNumber");
			ClearErrors("crtmitypeTitle");
			break;
	}
	
	switch (type2Field)
	{
		case  Item2ChoiceType.manufactureNum:
			ClearErrors("manufactureNum");
			if (string.IsNullOrWhiteSpace(manufactureNumField))
				AddError("manufactureNum", "Поле \"Заводской номер СИ\" не заполнено.");
			ClearErrors("inventoryNum");
			break;
		case  Item2ChoiceType.inventoryNum:
			ClearErrors("inventoryNum");
			if (string.IsNullOrWhiteSpace(inventoryNum))
				AddError("inventoryNum", "Поле \"Буквенно-цифровое обозначение\" не заполнено.");
			ClearErrors("manufactureNum");
			break;
	}
	
	
	
	}

	[XmlIgnore] private bool _isValidateField;

	[XmlIgnore]
	public bool IsValidate
	{
		get { return _isValidateField; }
		set
		{
			if (value == this._isValidateField) return;
			this._isValidateField = value;
			if (!_isValidateField) ClearAllErrors();
			OnPropertyChanged();
		}
	}

	#endregion
	
	
    public Item1ChoiceType Item1Type
    {
    	get {
            return this.type1Field;
        }
        set {            
    		if (value == this.type1Field) return;
			this.type1Field= value;
			OnPropertyChanged();    		
        }
    }
   
    public Item2ChoiceType Item2Type
    {
    	get {
            return this.type2Field;
        }
        set {            
    		if (value == this.type2Field) return;
			this.type2Field= value;
			OnPropertyChanged();    	
        }
    }
     
   
    /// <remarks/>
    public string mitypeNumber {
        get {
            return this.mitypeNumberField;
        }
        set {
	        if (value == this.mitypeNumberField) return;
	        this.mitypeNumberField= value;
	        OnPropertyChanged();
        }
    }
     
    /// <remarks/>
    public string crtmitypeTitle {
        get {
            return this.crtmitypeTitleField;
        }
        set {
	        if (value == this.crtmitypeTitleField) return;
            this.crtmitypeTitleField = value;
            OnPropertyChanged();
        }
    }
    
    /// <remarks/>
    public string milmitypeTitle {
        get {
            return this.milmitypeTitleField;
        }
        set {
	        if (value == this.milmitypeTitleField) return;
	        this.milmitypeTitleField = value;
	        OnPropertyChanged();
        }
    } 
    
    /// <remarks/>
    public string manufactureNum {
        get {
            return this. manufactureNumField;
        }
        set {
	        if (value == this.manufactureNumField) return;
	        this.manufactureNumField = value;
	        OnPropertyChanged();
        }
    }  
    /// <remarks/>
    public string inventoryNum {
        get {
            return this.inventoryNumField;
        }
        set {
	        if (value == this.inventoryNumField) return;
	        this.inventoryNumField = value;
	        OnPropertyChanged();
        }
    }
    
     /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(DataType="gYear")]    
    [Year]
    public string manufactureYear {
        get {
            return this.manufactureYearField;
        }
        set {
	        if (value == this.manufactureYearField) return;
	        this.manufactureYearField = value;
	        OnPropertyChanged();
        }
    }
    
    /// <remarks/>
    [Required (ErrorMessage ="Поле \"Модификация СИ\" не заполнено.", AllowEmptyStrings = false)]
    public string modification {
        get {
            return this.modificationField;
        }
        set {
	        if (value == this.modificationField) return;
	        this.modificationField = value;
	        OnPropertyChanged();
        }
    }    
}



/// <remarks/>
[System.SerializableAttribute()]
public enum Item1ChoiceType {
    
	/// <remarks/>
    mitypeNumber,
    
    /// <remarks/>
    milmitypeTitle,
    
	/// <remarks/>
    crtmitypeTitle  
   
}

/// <remarks/>
[System.SerializableAttribute()]
public enum Item2ChoiceType {
    
    /// <remarks/>
    manufactureNum,
    
	/// <remarks/>
    inventoryNum    
    
}

/// <remarks/>
[System.SerializableAttribute()]
public enum recInfoType {
    
    /// <remarks/>
    [Description("Первичная")]
    [System.Xml.Serialization.XmlEnumAttribute("1")]   
    Item1=1,
    
    /// <remarks/>
    [Description("Периодическая")]
    [System.Xml.Serialization.XmlEnumAttribute("2")]    
    Item2=2,
}




/// <remarks/>
[System.SerializableAttribute()]
public partial class recInfoApplicable : INotifyPropertyChanged
{
    	
	#region
	public event PropertyChangedEventHandler PropertyChanged;
	
	protected void OnPropertyChanged([CallerMemberName] string propertyName = "")
	{
		if (PropertyChanged != null) PropertyChanged.Invoke(this, new PropertyChangedEventArgs(propertyName));
		//PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
	}
	#endregion
	
    private string stickerNumField;
    
    private bool signPassField;
    
    private bool signMiField;
    
    /// <remarks/>
    public string stickerNum {
        get {
            return this.stickerNumField;
        }
        set {
	        if (value == this.stickerNumField) return;
            this.stickerNumField = value;
            OnPropertyChanged();
        }
    }
    
    [Required (ErrorMessage ="Поле \"Знак поверки в паспорте\" не заполнено.", AllowEmptyStrings = false)]
    /// <remarks/>    
    public bool signPass {
        get {
            return this.signPassField;
        }
        set {
            if (value == this.signPassField) return;
			this.signPassField = value;
			OnPropertyChanged();
        }
    }
    
    [Required (ErrorMessage ="Поле \"Знак поверки на СИ\" не заполнено.", AllowEmptyStrings = false)]
    /// <remarks/>
    public bool signMi {
        get {
            return this.signMiField;
        }
        set {
            if (value == this.signMiField) return;
			this.signMiField = value;
			OnPropertyChanged();
        }
    }
}

/// <remarks/>
[System.SerializableAttribute()]
public partial class recInfoInapplicable : INotifyPropertyChanged, INotifyDataErrorInfo
{
    
    private string reasonsField;
    
    #region
	public event PropertyChangedEventHandler PropertyChanged;
	
	protected void OnPropertyChanged([CallerMemberName] string propertyName = "")
	{
		if (PropertyChanged != null) PropertyChanged.Invoke(this, new PropertyChangedEventArgs(propertyName));
		//PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
		if (_isValidateField) Validate();
	}
	#endregion
    
	#region INotifyDataErrorInfo implementation

	private readonly Dictionary<string, List<string>> _errorsByPropertyName = new Dictionary<string, List<string>>();

	public event EventHandler<DataErrorsChangedEventArgs> ErrorsChanged;

	public IEnumerable GetErrors(string propertyName)
	{
		return _errorsByPropertyName.ContainsKey(propertyName) ? _errorsByPropertyName[propertyName] : null;
	}

	public bool HasErrors
	{
		get { return _errorsByPropertyName.Any(); }
	}

	private void OnErrorChanged(string propertyName)
	{
		if (ErrorsChanged != null) ErrorsChanged.Invoke(this, new DataErrorsChangedEventArgs(propertyName));
	}

	private void AddError(string propertyName, string error)
	{
		if (!_errorsByPropertyName.ContainsKey(propertyName))
			_errorsByPropertyName[propertyName] = new List<string>();
		if (!_errorsByPropertyName[propertyName].Contains(error))
		{
			_errorsByPropertyName[propertyName].Add(error);
			OnErrorChanged(propertyName);
		}
	}

	private void ClearErrors(string propertyName)
	{
		if (_errorsByPropertyName.ContainsKey(propertyName))
		{
			_errorsByPropertyName.Remove(propertyName);
			OnErrorChanged(propertyName);
		}
	}

	public void ClearAllErrors()
	{
		List<string> properties = new List<string>();
		foreach (KeyValuePair<string, List<string>> error in this._errorsByPropertyName)
			properties.Add(error.Key);
		this._errorsByPropertyName.Clear();
		foreach (string property in properties)
			this.OnPropertyChanged(property);
	}


	public void Validate()
	{
		ClearErrors("reasons");
		if (string.IsNullOrWhiteSpace(reasonsField))
			AddError("reasons", "Поле \"Причины непригодности\" не заполнено.");
	}

	[XmlIgnore] private bool _isValidateField;

	[XmlIgnore]
	public bool IsValidate
	{
		get { return _isValidateField; }
		set
		{
			if (value == this._isValidateField) return;
			this._isValidateField = value;
			if (!_isValidateField)
				ClearAllErrors();
			OnPropertyChanged();
		}
	}

	#endregion
	
	
     [Required (ErrorMessage ="Поле \"Причины непригодности\" не заполнено.", AllowEmptyStrings = false)]
    /// <remarks/>
    public string reasons {
        get {
            return this.reasonsField;
        }
        set {
	        if (value == this.reasonsField) return;
	        this.reasonsField = value;
	        OnPropertyChanged();
        }
    }
}


/// <remarks/>
[System.SerializableAttribute()]
public partial class recInfoMeans : INotifyPropertyChanged, INotifyDataErrorInfo
{
    #region
	public event PropertyChangedEventHandler PropertyChanged;
	
	protected void OnPropertyChanged([CallerMemberName] string propertyName = "")
	{
		if (PropertyChanged != null) PropertyChanged.Invoke(this, new PropertyChangedEventArgs(propertyName));
		//PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
		if (_isValidateField) Validate();
	}
	#endregion
	
	#region INotifyDataErrorInfo implementation

	private readonly Dictionary<string, List<string>> _errorsByPropertyName = new Dictionary<string, List<string>>();

	public event EventHandler<DataErrorsChangedEventArgs> ErrorsChanged;

	public IEnumerable GetErrors(string propertyName)
	{
		return _errorsByPropertyName.ContainsKey(propertyName) ? _errorsByPropertyName[propertyName] : null;
	}

	public bool HasErrors
	{
		get { return _errorsByPropertyName.Any(); }
	}

	private void OnErrorChanged(string propertyName)
	{
		if (ErrorsChanged != null) ErrorsChanged.Invoke(this, new DataErrorsChangedEventArgs(propertyName));
	}

	private void AddError(string propertyName, string error)
	{
		if (!_errorsByPropertyName.ContainsKey(propertyName))
			_errorsByPropertyName[propertyName] = new List<string>();
		if (!_errorsByPropertyName[propertyName].Contains(error))
		{
			_errorsByPropertyName[propertyName].Add(error);
			OnErrorChanged(propertyName);
		}
	}

	private void ClearErrors(string propertyName)
	{
		if (_errorsByPropertyName.ContainsKey(propertyName))
		{
			_errorsByPropertyName.Remove(propertyName);
			OnErrorChanged(propertyName);
		}
	}

	public void ClearAllErrors()
	{
		List<string> properties = new List<string>();
		foreach (KeyValuePair<string, List<string>> error in this._errorsByPropertyName)
			properties.Add(error.Key);
		this._errorsByPropertyName.Clear();
		foreach (string property in properties)
			this.OnPropertyChanged(property);
	}


	public void Validate()
	{
		npeField.IsValidate = true;
	}

	[XmlIgnore] private bool _isValidateField;

	[XmlIgnore]
	public bool IsValidate
	{
		get { return _isValidateField; }
		set
		{
			if (value == this._isValidateField) return;
			this._isValidateField = value;
			if (!_isValidateField)
			{
				ClearAllErrors();
				npeField.IsValidate = false;
				uveField.IsValidate = false;
				sesField.IsValidate = false;
				mietaField.IsValidate = false;
				misField.IsValidate = false;
				reagentField.IsValidate = false;
			}
			else
			{
				npeField.IsValidate = true;
				uveField.IsValidate = true;
				sesField.IsValidate = true;
				mietaField.IsValidate = true;
				misField.IsValidate = true;
				reagentField.IsValidate = true;
			}
			OnPropertyChanged();
		}
	}

	#endregion
	
	private recInfoNpe npeField;
	private recInfoUve uveField;
	private recInfoSes sesField;	
	private	recInfoMieta mietaField;
	private recInfoMis misField;	
	private recInfoReagent reagentField;	
	private bool isoMethodField;
	private recInfoOMethod? oMethodField; //= default(recInfoOMethod); 
	
	public recInfoMeans()
	{		
		npeField = new recInfoNpe();
		uveField = new recInfoUve();
		sesField = new recInfoSes();	
		mietaField = new recInfoMieta();
		misField = new recInfoMis();	
		reagentField = new recInfoReagent();	
		oMethodField = recInfoOMethod.Item1; //= default(recInfoOMethod); 

		_isValidateField = false;
		
		npeField.CollectionChanged += OnCollectionChanged;
		npeField.ItemPropertyChanged += OnItemPropertyChanged;
		
		uveField.CollectionChanged += OnCollectionChanged;
		uveField.ItemPropertyChanged += OnItemPropertyChanged;
		
		sesField.CollectionChanged += OnCollectionChanged;
		sesField.ItemPropertyChanged += OnItemPropertyChanged;
		
		mietaField.CollectionChanged += OnCollectionChanged;
		mietaField.ItemPropertyChanged += OnItemPropertyChanged;
		
		misField.CollectionChanged += OnCollectionChanged;
		misField.ItemPropertyChanged += OnItemPropertyChanged;
		
		reagentField.CollectionChanged += OnCollectionChanged;
		reagentField.ItemPropertyChanged += OnItemPropertyChanged;
	}

	private void OnItemPropertyChanged(object sender, PropertyChangedEventArgs e)
	{
		if (PropertyChanged != null) PropertyChanged.Invoke(this, new PropertyChangedEventArgs(null));
	}

	private void OnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
	{
		if (PropertyChanged != null) PropertyChanged.Invoke(this, new PropertyChangedEventArgs(null));
	}

	public recInfoNpe npe
	{ 
		get
		{
			return npeField;
		}
		set
		{
			if (value == this.npeField) return;
			this.npeField = value;
			OnPropertyChanged();
		}
	}		
	public recInfoUve uve
	{
		get
		{
			return uveField;
		}
		set
		{
			if (value == this.uveField) return;
			this.uveField = value;
			OnPropertyChanged();
		}	
	}	
	public recInfoSes ses
	{
		get
		{
			return sesField;
		}
		set
		{
			if (value == this.sesField) return;
			this.sesField = value;
			OnPropertyChanged();
		}
	}	
	public recInfoMieta mieta
	{
		get
		{
			return mietaField;
		}
		set
		{
			if (value == this.mietaField) return;
			this.mietaField = value;
			OnPropertyChanged();
		}
	}	
	public recInfoMis mis
	{
		get
		{
			return misField;
		}
		set
		{
			if (value == this.misField) return;
			this.misField = value;
			OnPropertyChanged();
		}
	}	
	public recInfoReagent reagent 
	{
		get
		{
			return reagentField;
		}
		set
		{
			if (value == this.reagentField) return;
			this.reagentField = value;
			OnPropertyChanged();
		}
	}
	
	public bool IsoMethod
	{
		get {
            return this.isoMethodField;
        }
        set {
            if (value == this.isoMethodField) return;
			this.isoMethodField = value;
			OnPropertyChanged();    		
        }
	
	}
	
	public recInfoOMethod? oMethod
	{
		get {
            return this.oMethodField;
        }
        set {
            if (value == this.oMethodField) return;
			this.oMethodField = value;
			OnPropertyChanged();    		
        }
	}		

	
}

[Serializable]
/// <summary>
/// Это мой класс. Создал чтобы описать number
/// </summary>
public class Number : INotifyPropertyChanged, INotifyDataErrorInfo
{
	#region
	public event PropertyChangedEventHandler PropertyChanged;
	
	protected void OnPropertyChanged([CallerMemberName] string propertyName = "")
	{
		if (PropertyChanged != null) PropertyChanged.Invoke(this, new PropertyChangedEventArgs(propertyName));
		//PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
		if (_isValidateField) Validate();
	}
	#endregion

	
	#region INotifyDataErrorInfo implementation

	private readonly Dictionary<string, List<string>> _errorsByPropertyName = new Dictionary<string, List<string>>();

	public event EventHandler<DataErrorsChangedEventArgs> ErrorsChanged;

	public IEnumerable GetErrors(string propertyName)
	{
		return _errorsByPropertyName.ContainsKey(propertyName) ? _errorsByPropertyName[propertyName] : null;
	}

	public bool HasErrors
	{
		get { return _errorsByPropertyName.Any(); }
	}

	private void OnErrorChanged(string propertyName)
	{
		if (ErrorsChanged != null) ErrorsChanged.Invoke(this, new DataErrorsChangedEventArgs(propertyName));
	}

	private void AddError(string propertyName, string error)
	{
		if (!_errorsByPropertyName.ContainsKey(propertyName))
			_errorsByPropertyName[propertyName] = new List<string>();
		if (!_errorsByPropertyName[propertyName].Contains(error))
		{
			_errorsByPropertyName[propertyName].Add(error);
			OnErrorChanged(propertyName);
		}
	}

	private void ClearErrors(string propertyName)
	{
		if (_errorsByPropertyName.ContainsKey(propertyName))
		{
			_errorsByPropertyName.Remove(propertyName);
			OnErrorChanged(propertyName);
		}
	}

	public void ClearAllErrors()
	{
		List<string> properties = new List<string>();
		foreach (KeyValuePair<string, List<string>> error in this._errorsByPropertyName)
			properties.Add(error.Key);
		this._errorsByPropertyName.Clear();
		foreach (string property in properties)
			this.OnPropertyChanged(property);
	}


	public void Validate()
	{
		ClearErrors("number");
		if (string.IsNullOrWhiteSpace(numberField))
			AddError("number", "Поле не заполнено."); //ЗДЕСЬ В КЛАСС можно добавить определение поля, чтобы выводить разные подсказки в зависимости от типа number 
	}

	[XmlIgnore] private bool _isValidateField;

	[XmlIgnore]
	public bool IsValidate
	{
		get { return _isValidateField; }
		set
		{
			if (value == this._isValidateField) return;
			this._isValidateField = value;
			if (!_isValidateField)
			{
				ClearAllErrors();
			}
			OnPropertyChanged();
		}
	}

	#endregion
	
	private string numberField;
	
	public string number
	{
		get {
			return this.numberField;
		}
		set {
			if (value == this.numberField) return;
			this.numberField = value;
			OnPropertyChanged();
		}
	}
			
	public Number(string number): base ()
	{
		this.numberField = number;	
	}
	
	public Number()
	{
		_isValidateField = false;
	}
	
	public override string ToString()
	{
		return number;
	}
}

/// <remarks/>
[System.SerializableAttribute()]
public partial class recInfoNpe : ObservableCollection<Number>
{
	
	public recInfoNpe()
	{
		CollectionChanged += OnCollectionChanged;
		_isValidateField = false;
	}


	private void OnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
	{
		if (e.Action == NotifyCollectionChangedAction.Add)
		{
			foreach (Number number in e.NewItems)
			{
				number.PropertyChanged += OnPropertyChangeEventHandler;
				if (_isValidateField) number.IsValidate = true;
				else
				{
					number.IsValidate = false;
				}
			}
		}
	}

	public event PropertyChangedEventHandler ItemPropertyChanged;
	
	private void OnPropertyChangeEventHandler(object sender, PropertyChangedEventArgs e)
	{
		//Number n = e.PropertyName
		if (this.ItemPropertyChanged != null) ItemPropertyChanged.Invoke(this, new PropertyChangedEventArgs(e.PropertyName));
		
	}
	
	private bool _isValidateField;

	public bool IsValidate
	{
		get { return _isValidateField; }
		set
		{
			if (value == this._isValidateField) return;
			this._isValidateField = value;
			if (!_isValidateField)
			{
				foreach (var number in this.Items)
					number.IsValidate = false;
			}
			else
			{
				foreach (var number in this.Items)
					number.IsValidate = true;
			}
		}
	}

	/*
   // команда добавления нового объекта
        private RelayCommand addCommand;
        public RelayCommand AddCommand
        {
            get
            {
                return addCommand ??
                  (addCommand = new RelayCommand(obj =>
                  {
                      Number number = new Number();
                      this.Insert(0, number);
                      //SelectedPhone = phone;
                  }));
            }
        }   
   
   
   // команда удаления
   private RelayCommand removeCommand;
   public RelayCommand RemoveCommand
   {
           get
            {
                return removeCommand ??
                  (removeCommand = new RelayCommand(obj =>
                  {
                      Number number = obj as Number;
                      if (number != null)
                      {
                          this.Remove(number);
                      }
                  },
                 (obj) => this.Count > 0));
          }
   } 
   */

}

/// <remarks/>
[System.SerializableAttribute()]
public partial class recInfoUve :  ObservableCollection<Number>
{
	public recInfoUve()
	{
		CollectionChanged += OnCollectionChanged;
		_isValidateField = false;
	}

	private void OnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
	{
		if (e.Action == NotifyCollectionChangedAction.Add)
		{
			foreach (Number number in e.NewItems)
			{
				number.PropertyChanged += OnPropertyChangeEventHandler;
				if (_isValidateField) number.IsValidate = true;
				else
				{
					number.IsValidate = false;
				}
			}
		}
	}

	public event PropertyChangedEventHandler ItemPropertyChanged;
	
	private void OnPropertyChangeEventHandler(object sender, PropertyChangedEventArgs e)
	{
		if (this.ItemPropertyChanged != null) ItemPropertyChanged.Invoke(this, new PropertyChangedEventArgs(e.PropertyName));
	}
	
	private bool _isValidateField;

	public bool IsValidate
	{
		get { return _isValidateField; }
		set
		{
			if (value == this._isValidateField) return;
			this._isValidateField = value;
			if (!_isValidateField)
			{
				foreach (var number in this.Items)
					number.IsValidate = false;
			}
			else
			{
				foreach (var number in this.Items)
					number.IsValidate = true;
			}
		}
	}
}

[System.SerializableAttribute()]
public partial class recInfoMieta : ObservableCollection<Number>
{  
	public recInfoMieta()
	{
		CollectionChanged += OnCollectionChanged;
		_isValidateField = false;
	}

	private void OnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
	{
		if (e.Action == NotifyCollectionChangedAction.Add)
		{
			foreach (Number number in e.NewItems)
			{
				number.PropertyChanged += OnPropertyChangeEventHandler;
				if (_isValidateField) number.IsValidate = true;
				else
				{
					number.IsValidate = false;
				}
			}
		}
	}

	public event PropertyChangedEventHandler ItemPropertyChanged;
	
	private void OnPropertyChangeEventHandler(object sender, PropertyChangedEventArgs e)
	{
		if (this.ItemPropertyChanged != null) ItemPropertyChanged.Invoke(this, new PropertyChangedEventArgs(e.PropertyName));
	}
	
	private bool _isValidateField;

	public bool IsValidate
	{
		get { return _isValidateField; }
		set
		{
			if (value == this._isValidateField) return;
			this._isValidateField = value;
			if (!_isValidateField)
			{
				foreach (var number in this.Items)
					number.IsValidate = false;
			}
			else
			{
				foreach (var number in this.Items)
					number.IsValidate = true;
			}
		}
	}
	
}


[Serializable]
public partial class recInfoMisMI : ICloneable, INotifyPropertyChanged, INotifyDataErrorInfo
{
    	
	#region
	public event PropertyChangedEventHandler PropertyChanged;
	
	protected void OnPropertyChanged([CallerMemberName] string propertyName = "")
	{
		if (PropertyChanged != null) PropertyChanged.Invoke(this, new PropertyChangedEventArgs(propertyName));
		//PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
		if (_isValidateField) Validate();
	}
	#endregion INotifyPropertyChanged implementation
    
	public object Clone()
	{
		return this.MemberwiseClone();
	}
	
	#region INotifyDataErrorInfo implementation

	private readonly Dictionary<string, List<string>> _errorsByPropertyName = new Dictionary<string, List<string>>();

	public event EventHandler<DataErrorsChangedEventArgs> ErrorsChanged;

	public IEnumerable GetErrors(string propertyName)
	{
		return _errorsByPropertyName.ContainsKey(propertyName) ? _errorsByPropertyName[propertyName] : null;
	}

	public bool HasErrors
	{
		get { return _errorsByPropertyName.Any(); }
	}

	private void OnErrorChanged(string propertyName)
	{
		if (ErrorsChanged != null) ErrorsChanged.Invoke(this, new DataErrorsChangedEventArgs(propertyName));
	}

	private void AddError(string propertyName, string error)
	{
		if (!_errorsByPropertyName.ContainsKey(propertyName))
			_errorsByPropertyName[propertyName] = new List<string>();
		if (!_errorsByPropertyName[propertyName].Contains(error))
		{
			_errorsByPropertyName[propertyName].Add(error);
			OnErrorChanged(propertyName);
		}
	}

	private void ClearErrors(string propertyName)
	{
		if (_errorsByPropertyName.ContainsKey(propertyName))
		{
			_errorsByPropertyName.Remove(propertyName);
			OnErrorChanged(propertyName);
		}
	}

	public void ClearAllErrors()
	{
		List<string> properties = new List<string>();
		foreach (KeyValuePair<string, List<string>> error in this._errorsByPropertyName)
			properties.Add(error.Key);
		this._errorsByPropertyName.Clear();
		foreach (string property in properties)
			this.OnPropertyChanged(property);
	}


	public void Validate()
	{
		ClearErrors("typeNum");
		if (string.IsNullOrWhiteSpace(typeNumField))
			AddError("typeNum", "Поле \"Регистрационный номер типа СИ\" не заполнено.");
		
		if (typeField == Item2ChoiceType.manufactureNum) 
		{
			ClearErrors("manufactureNum");
			if (string.IsNullOrWhiteSpace(manufactureNumField))
				AddError("manufactureNum", "Поле \"Заводской номер СИ\" не заполнено.");
			ClearErrors("inventoryNum");
		}
		else
		{
			ClearErrors("inventoryNum");
			if (string.IsNullOrWhiteSpace(inventoryNumField))
				AddError("inventoryNum", "Поле \"Буквенно-цифровое обозначение\" не заполнено.");
			ClearErrors("manufactureNum");
		}
	}
	

	[XmlIgnore] private bool _isValidateField;

	[XmlIgnore]
	public bool IsValidate
	{
		get { return _isValidateField; }
		set
		{
			if (value == this._isValidateField) return;
			this._isValidateField = value;
			if (!_isValidateField) ClearAllErrors();
			OnPropertyChanged();
		}
	}

	#endregion

	private string typeNumField;
    
    private string manufactureNumField;
    
    private string inventoryNumField;
    
    private Item2ChoiceType typeField;
    
 	[Required (ErrorMessage ="Поле \"Регистрационный номер типа СИ\" не заполнено.", AllowEmptyStrings = false)]    
    /// <remarks/>
    public string typeNum {
        get {
            return this.typeNumField;
        }
        set {
	        if (value == this.typeNumField) return;
	        this.typeNumField = value;
	        OnPropertyChanged();
        }
    }
    
    /// <remarks/>
    public string manufactureNum {
        get {
            return this.manufactureNumField;
        }
        set {
	        if (value == this.manufactureNumField) return;
	        this.manufactureNumField = value;
	        OnPropertyChanged();
        }
    }
    
    /// <remarks/>
    public string inventoryNum {
        get {
            return this.inventoryNumField;
        }
        set {
	        if (value == this.inventoryNumField) return;
	        this.inventoryNumField = value;
	        OnPropertyChanged();
        }
    }
    
    public Item2ChoiceType Type
    {
    	get {
            return this.typeField;
        }
        set {
	        if (value == this.typeField) return;
	        this.typeField = value;
	        OnPropertyChanged();
        }    
    }

    public recInfoMisMI()
    {
	    _isValidateField = false;
    }

}

[Serializable]
public partial class recInfoMis : ObservableCollection<recInfoMisMI>
{
	public recInfoMis CreateCopy()
    {        
        recInfoMis copy = new recInfoMis();	
		foreach (var mi in Items)
		{				
				recInfoMisMI newmi = (recInfoMisMI)mi.Clone();
				if (mi.Type == Item2ChoiceType.manufactureNum)
				{
					newmi.inventoryNum = null;
				}
				else 
				{
					newmi.manufactureNum = null;
				}
				copy.Items.Add(newmi);				
		}		
		return copy;
    }
	
	
	public recInfoMis()
	{
		CollectionChanged += OnCollectionChanged;
	}


	private void OnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
	{
		if (e.Action == NotifyCollectionChangedAction.Add)
		{
			foreach (recInfoMisMI mi in e.NewItems)
			{
				mi.PropertyChanged += OnPropertyChangeEventHandler;
				if (_isValidateField) mi.IsValidate = true;
				else
				{
					mi.IsValidate = false;
				}
			}
		}
	}

	public event PropertyChangedEventHandler ItemPropertyChanged;
	
	private void OnPropertyChangeEventHandler(object sender, PropertyChangedEventArgs e)
	{
		if (this.ItemPropertyChanged != null) ItemPropertyChanged.Invoke(this, new PropertyChangedEventArgs(e.PropertyName));
	}
	
	private bool _isValidateField;

	public bool IsValidate
	{
		get { return _isValidateField; }
		set
		{
			if (value == this._isValidateField) return;
			this._isValidateField = value;
			if (!_isValidateField)
			{
				foreach (var mi in this.Items)
					mi.IsValidate = false;
			}
			else
			{
				foreach (var mi in this.Items)
					mi.IsValidate = true;
			}
		}
	}
}



/// <remarks/>
[System.SerializableAttribute()]
public enum recInfoOMethod {
       
    /// <remarks/>
    [Description("Поверка имитационным методом")]
    [System.Xml.Serialization.XmlEnumAttribute("1")]
    Item1=1,
    
    /// <remarks/>
    [Description("Самоповерка")]
    [System.Xml.Serialization.XmlEnumAttribute("2")]
    Item2=2,
    
    /// <remarks/>
    [Description("Поверка расчетным методом")]
    [System.Xml.Serialization.XmlEnumAttribute("3")]
    Item3=3,
    
    /// <remarks/>
    [Description("Поверка с использованием первичной референтной методики измерений")]
    [System.Xml.Serialization.XmlEnumAttribute("4")]
    Item4=4,
}

[System.SerializableAttribute()]
public partial class recInfoReagent : ObservableCollection<Number>
{    
	public recInfoReagent()
	{
		CollectionChanged += OnCollectionChanged;
		_isValidateField = false;
	}

	private void OnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
	{
		if (e.Action == NotifyCollectionChangedAction.Add)
		{
			foreach (Number number in e.NewItems)
			{
				number.PropertyChanged += OnPropertyChangeEventHandler;
				if (_isValidateField) number.IsValidate = true;
				else
				{
					number.IsValidate = false;
				}
			}
		}
	}

	public event PropertyChangedEventHandler ItemPropertyChanged;
	
	private void OnPropertyChangeEventHandler(object sender, PropertyChangedEventArgs e)
	{
		if (this.ItemPropertyChanged != null) ItemPropertyChanged.Invoke(this, new PropertyChangedEventArgs(e.PropertyName));
	}
	
	private bool _isValidateField;

	public bool IsValidate
	{
		get { return _isValidateField; }
		set
		{
			if (value == this._isValidateField) return;
			this._isValidateField = value;
			if (!_isValidateField)
			{
				foreach (var number in this.Items)
					number.IsValidate = false;
			}
			else
			{
				foreach (var number in this.Items)
					number.IsValidate = true;
			}
		}
	}
}


/// <remarks/>
[System.SerializableAttribute()]
public partial class recInfoSesSE : INotifyPropertyChanged, INotifyDataErrorInfo
{
    	
	#region
	public event PropertyChangedEventHandler PropertyChanged;
	
	protected void OnPropertyChanged([CallerMemberName] string propertyName = "")
	{
		if (PropertyChanged != null) PropertyChanged.Invoke(this, new PropertyChangedEventArgs(propertyName));
		//PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
		if (_isValidateField) Validate();
	}
	#endregion
    
	#region INotifyDataErrorInfo implementation

	private readonly Dictionary<string, List<string>> _errorsByPropertyName = new Dictionary<string, List<string>>();

	public event EventHandler<DataErrorsChangedEventArgs> ErrorsChanged;

	public IEnumerable GetErrors(string propertyName)
	{
		return _errorsByPropertyName.ContainsKey(propertyName) ? _errorsByPropertyName[propertyName] : null;
	}

	public bool HasErrors
	{
		get { return _errorsByPropertyName.Any(); }
	}

	private void OnErrorChanged(string propertyName)
	{
		if (ErrorsChanged != null) ErrorsChanged.Invoke(this, new DataErrorsChangedEventArgs(propertyName));
	}

	private void AddError(string propertyName, string error)
	{
		if (!_errorsByPropertyName.ContainsKey(propertyName))
			_errorsByPropertyName[propertyName] = new List<string>();
		if (!_errorsByPropertyName[propertyName].Contains(error))
		{
			_errorsByPropertyName[propertyName].Add(error);
			OnErrorChanged(propertyName);
		}
	}

	private void ClearErrors(string propertyName)
	{
		if (_errorsByPropertyName.ContainsKey(propertyName))
		{
			_errorsByPropertyName.Remove(propertyName);
			OnErrorChanged(propertyName);
		}
	}

	public void ClearAllErrors()
	{
		List<string> properties = new List<string>();
		foreach (KeyValuePair<string, List<string>> error in this._errorsByPropertyName)
			properties.Add(error.Key);
		this._errorsByPropertyName.Clear();
		foreach (string property in properties)
			this.OnPropertyChanged(property);
	}


	public void Validate()
	{
		ClearErrors("typeNum");
		if (string.IsNullOrWhiteSpace(typeNumField))
			AddError("typeNum", "Поле \"Номер типа СО по реестру\" не заполнено.");
		
		ClearErrors("manufactureYear");
		if (string.IsNullOrWhiteSpace(manufactureYearField))
			AddError("manufactureYear", "Поле \"Год выпуска\" не заполнено.");
	}

	[XmlIgnore] private bool _isValidateField;

	[XmlIgnore]
	public bool IsValidate
	{
		get { return _isValidateField; }
		set
		{
			if (value == this._isValidateField) return;
			this._isValidateField = value;
			if (!_isValidateField) ClearAllErrors();
			OnPropertyChanged();
		}
	}

	#endregion
	
	
	
	private string typeNumField;
    
    private string manufactureYearField;
    
    private string manufactureNumField;
    
    private string metroCharsField;
    
    [Required (ErrorMessage ="Поле \"Номер типа СО по реестру\" не заполнено.", AllowEmptyStrings = false)]
    /// <remarks/>
    public string typeNum {
        get {
            return this.typeNumField;
        }
        set {
	        if (value == this.typeNumField) return;
	        this.typeNumField = value;
	        OnPropertyChanged();
        }
    }
    
    /// <remarks/>
    [Required (ErrorMessage ="Поле \"Год выпуска\" не заполнено.", AllowEmptyStrings = false)]
    [System.Xml.Serialization.XmlElementAttribute(DataType="gYear")]
    [Year]
    public string manufactureYear {
        get {
            return this.manufactureYearField;
        }
        set {
	        if (value == this.manufactureYearField) return;
	        this.manufactureYearField = value;
	        OnPropertyChanged();
        }
    }
    
    /// <remarks/>
    public string manufactureNum {
        get {
            return this.manufactureNumField;
        }
        set {
	        if (value == this.manufactureNumField) return;
	        this.manufactureNumField = value;
	        OnPropertyChanged();
        }
    }
    
    /// <remarks/>
    public string metroChars {
        get {
            return this.metroCharsField;
        }
        set {
	        if (value == this.metroCharsField) return;
	        this.metroCharsField = value;
	        OnPropertyChanged();
        }
    }

    public recInfoSesSE()
    {
	    _isValidateField = false;
    }
}

/// <remarks/>
[System.SerializableAttribute()]
public partial class recInfoSes : ObservableCollection<recInfoSesSE> 
{
	public recInfoSes()
	{
		CollectionChanged += OnCollectionChanged;
	}


	private void OnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
	{
		if (e.Action == NotifyCollectionChangedAction.Add)
		{
			foreach (recInfoSesSE se in e.NewItems)
			{
				se.PropertyChanged += OnPropertyChangeEventHandler;
				if (_isValidateField) se.IsValidate = true;
				else
				{
					se.IsValidate = false;
				}
			}
		}
	}

	public event PropertyChangedEventHandler ItemPropertyChanged;
	
	private void OnPropertyChangeEventHandler(object sender, PropertyChangedEventArgs e)
	{
		if (this.ItemPropertyChanged != null) ItemPropertyChanged.Invoke(this, new PropertyChangedEventArgs(e.PropertyName));
	}
	
	private bool _isValidateField;

	public bool IsValidate
	{
		get { return _isValidateField; }
		set
		{
			if (value == this._isValidateField) return;
			this._isValidateField = value;
			if (!_isValidateField)
			{
				foreach (var se in this.Items)
					se.IsValidate = false;
			}
			else
			{
				foreach (var se in this.Items)
					se.IsValidate = true;
			}
		}
	}
    
}


/// <remarks/>
[System.SerializableAttribute()]
public enum ItemsChoiceType {
    
    /// <remarks/>
    mieta,
    
    /// <remarks/>
    mis,
    
    /// <remarks/>
    npe,
    
    /// <remarks/>
    oMethod,
    
    /// <remarks/>
    reagent,
    
    /// <remarks/>
    ses,
    
    /// <remarks/>
    uve,
}

/// <remarks/>
[System.SerializableAttribute()]
public partial class recInfoConditions : INotifyPropertyChanged, INotifyDataErrorInfo
{
    	
#region
public event PropertyChangedEventHandler PropertyChanged;
	
protected void OnPropertyChanged([CallerMemberName] string propertyName = "")
{
	if (PropertyChanged != null) PropertyChanged.Invoke(this, new PropertyChangedEventArgs(propertyName));
	//PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
	if (_isValidateField) Validate();
}
#endregion
   
#region INotifyDataErrorInfo implementation

private readonly Dictionary<string, List<string>> _errorsByPropertyName = new Dictionary<string, List<string>>();

public event EventHandler<DataErrorsChangedEventArgs> ErrorsChanged;

public IEnumerable GetErrors(string propertyName)
{
	return _errorsByPropertyName.ContainsKey(propertyName) ? _errorsByPropertyName[propertyName] : null;
}

public bool HasErrors
{
	get { return _errorsByPropertyName.Any(); }
}

private void OnErrorChanged(string propertyName)
{
	if (ErrorsChanged != null) ErrorsChanged.Invoke(this, new DataErrorsChangedEventArgs(propertyName));
}

private void AddError(string propertyName, string error)
{
	if (!_errorsByPropertyName.ContainsKey(propertyName))
		_errorsByPropertyName[propertyName] = new List<string>();
	if (!_errorsByPropertyName[propertyName].Contains(error))
	{
		_errorsByPropertyName[propertyName].Add(error);
		OnErrorChanged(propertyName);
	}
}

private void ClearErrors(string propertyName)
{
	if (_errorsByPropertyName.ContainsKey(propertyName))
	{
		_errorsByPropertyName.Remove(propertyName);
		OnErrorChanged(propertyName);
	}
}

public void ClearAllErrors()
{
	List<string> properties = new List<string>();
	foreach (KeyValuePair<string, List<string>> error in this._errorsByPropertyName)
		properties.Add(error.Key);
	this._errorsByPropertyName.Clear();
	foreach (string property in properties)
		this.OnPropertyChanged(property);
}


public void Validate()
{
	ClearErrors("temperature");
	if (string.IsNullOrWhiteSpace(temperatureField))
		AddError("temperature", "Поле \"Температура\" не заполнено.");
	ClearErrors("pressure");
	if (string.IsNullOrWhiteSpace(pressureField))
		AddError("pressure", "Поле \"Атмосферное давление\" не заполнено.");
	ClearErrors("hymidity");
	if (string.IsNullOrWhiteSpace(hymidityField))
		AddError("hymidity", "Поле \"Относительная влажность\" не заполнено.");
}

[XmlIgnore] private bool _isValidateField;

[XmlIgnore]
public bool IsValidate
{
	get { return _isValidateField; }
	set
	{
		if (value == this._isValidateField) return;
		this._isValidateField = value;
		if (!_isValidateField) ClearAllErrors();
		OnPropertyChanged();
	}
}

#endregion

	private string temperatureField;
    
    private string pressureField;
    
    private string hymidityField;
    
    private string otherField;

    public recInfoConditions()
    {
	    _isValidateField = false;
    }
    
    
   [Required (ErrorMessage ="Поле \"Температура\" не заполнено.", AllowEmptyStrings = false)]
    /// <remarks/>
    public string temperature {
        get {
            return this.temperatureField;
        }
        set {
	        if (value == this.temperatureField) return;
	        this.temperatureField = value;
	        OnPropertyChanged();
        }
    }
    
    [Required (ErrorMessage ="Поле \"Атмосферное давление\" не заполнено.", AllowEmptyStrings = false)]
    /// <remarks/>
    public string pressure {
        get {
            return this.pressureField;
        }
        set {
	        if (value == this.pressureField) return;
	        this.pressureField = value;
	        OnPropertyChanged();
        }
    }
    
    [Required (ErrorMessage ="Поле \"Относительная влажность\" не заполнено.", AllowEmptyStrings = false)]
    /// <remarks/>
    public string hymidity {
        get {
            return this.hymidityField;
        }
        set {
	        if (value == this.hymidityField) return;
	        this.hymidityField = value;
	        OnPropertyChanged();
        }
    }
    
    /// <remarks/>
    public string other {
        get {
            return this.otherField;
        }
        set {
	        if (value == this.otherField) return;
	        this.otherField = value;
	        OnPropertyChanged();
        }
    }
}

/// <remarks/>
[System.SerializableAttribute()]
public partial class recInfoBrief_procedure : INotifyPropertyChanged, INotifyDataErrorInfo
{
    	
	#region
	public event PropertyChangedEventHandler PropertyChanged;
	
	protected void OnPropertyChanged([CallerMemberName] string propertyName = "")
	{
		if (PropertyChanged != null) PropertyChanged.Invoke(this, new PropertyChangedEventArgs(propertyName));
		//PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
		if (_isValidateField) Validate();
	}
	#endregion
    
	#region INotifyDataErrorInfo implementation

	private readonly Dictionary<string, List<string>> _errorsByPropertyName = new Dictionary<string, List<string>>();

	public event EventHandler<DataErrorsChangedEventArgs> ErrorsChanged;

	public IEnumerable GetErrors(string propertyName)
	{
		return _errorsByPropertyName.ContainsKey(propertyName) ? _errorsByPropertyName[propertyName] : null;
	}

	public bool HasErrors
	{
		get { return _errorsByPropertyName.Any(); }
	}

	private void OnErrorChanged(string propertyName)
	{
		if (ErrorsChanged != null) ErrorsChanged.Invoke(this, new DataErrorsChangedEventArgs(propertyName));
	}

	private void AddError(string propertyName, string error)
	{
		if (!_errorsByPropertyName.ContainsKey(propertyName))
			_errorsByPropertyName[propertyName] = new List<string>();
		if (!_errorsByPropertyName[propertyName].Contains(error))
		{
			_errorsByPropertyName[propertyName].Add(error);
			OnErrorChanged(propertyName);
		}
	}

	private void ClearErrors(string propertyName)
	{
		if (_errorsByPropertyName.ContainsKey(propertyName))
		{
			_errorsByPropertyName.Remove(propertyName);
			OnErrorChanged(propertyName);
		}
	}

	public void ClearAllErrors()
	{
		List<string> properties = new List<string>();
		foreach (KeyValuePair<string, List<string>> error in this._errorsByPropertyName)
			properties.Add(error.Key);
		this._errorsByPropertyName.Clear();
		foreach (string property in properties)
			this.OnPropertyChanged(property);
	}


	public void Validate()
	{
		ClearErrors("characteristics");
		if (string.IsNullOrWhiteSpace(characteristicsField))
			AddError("characteristics", "Краткая характеристика объема поверки\" не заполнено.");
	}

	[XmlIgnore] private bool _isValidateField;

	[XmlIgnore]
	public bool IsValidate
	{
		get { return _isValidateField; }
		set
		{
			if (value == this._isValidateField) return;
			this._isValidateField = value;
			if (!_isValidateField) ClearAllErrors();
			OnPropertyChanged();
		}
	}

	#endregion

	public recInfoBrief_procedure()
	{
		_isValidateField = false;
	}
	
	private string characteristicsField;
    
    [Required (ErrorMessage ="Поле \"Краткая характеристика объема поверки\" не заполнено.", AllowEmptyStrings = false)]
    /// <remarks/>
    /// <remarks/>
    public string characteristics {
        get {
            return this.characteristicsField;
        }
        set {
	        if (value == this.characteristicsField) return;
	        this.characteristicsField = value;
	        OnPropertyChanged();
           
        }
    }
}

/// <remarks/>
[System.SerializableAttribute()]
public partial class recInfoProtocol : INotifyPropertyChanged, INotifyDataErrorInfo
{
    #region
	public event PropertyChangedEventHandler PropertyChanged;
	
	protected void OnPropertyChanged([CallerMemberName] string propertyName = "")
	{
		if (PropertyChanged != null) PropertyChanged.Invoke(this, new PropertyChangedEventArgs(propertyName));
		//PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
		if (_isValidateField) Validate();
	}
	#endregion
	
	   
#region INotifyDataErrorInfo implementation

private readonly Dictionary<string, List<string>> _errorsByPropertyName = new Dictionary<string, List<string>>();

public event EventHandler<DataErrorsChangedEventArgs> ErrorsChanged;

public IEnumerable GetErrors(string propertyName)
{
	return _errorsByPropertyName.ContainsKey(propertyName) ? _errorsByPropertyName[propertyName] : null;
}

public bool HasErrors
{
	get { return _errorsByPropertyName.Any(); }
}

private void OnErrorChanged(string propertyName)
{
	if (ErrorsChanged != null) ErrorsChanged.Invoke(this, new DataErrorsChangedEventArgs(propertyName));
}

private void AddError(string propertyName, string error)
{
	if (!_errorsByPropertyName.ContainsKey(propertyName))
		_errorsByPropertyName[propertyName] = new List<string>();
	if (!_errorsByPropertyName[propertyName].Contains(error))
	{
		_errorsByPropertyName[propertyName].Add(error);
		OnErrorChanged(propertyName);
	}
}

private void ClearErrors(string propertyName)
{
	if (_errorsByPropertyName.ContainsKey(propertyName))
	{
		_errorsByPropertyName.Remove(propertyName);
		OnErrorChanged(propertyName);
	}
}

public void ClearAllErrors()
{
	List<string> properties = new List<string>();
	foreach (KeyValuePair<string, List<string>> error in this._errorsByPropertyName)
		properties.Add(error.Key);
	this._errorsByPropertyName.Clear();
	foreach (string property in properties)
		this.OnPropertyChanged(property);
}


public void Validate()
{
	ClearErrors("fullfilename");
	if (string.IsNullOrWhiteSpace(fullfilenameField))
		AddError("fullfilename", "Поле \"Наименование файла\" не заполнено. Файл должен быть не более 1 Мб и одного из следующих типов: *.pdf, *.zip, *.djvu или формата MS Word"); 
}

[XmlIgnore] private bool _isValidateField;

[XmlIgnore]
public bool IsValidate
{
	get { return _isValidateField; }
	set
	{
		if (value == this._isValidateField) return;
		this._isValidateField = value;
		if (!_isValidateField) ClearAllErrors();
		OnPropertyChanged();
	}
}

#endregion
	
    private byte[] contentField;    
       
    private recInfoProtocolMimetype? mimetypeField;
    
    private string filenameField;
    
    private string fullfilenameField;

    public recInfoProtocol()
    {
	    _isValidateField = false;
    }
    
    [Required (ErrorMessage ="Поле \"Содержимое файла протокола поверки\" не заполнено.", AllowEmptyStrings = false)]
    /// <remarks/>
    [System.Xml.Serialization.XmlElementAttribute(DataType="base64Binary")]
    public byte[] content {
        get {
            return this.contentField;
        }
        set {
           	if (value == this.contentField) return;
			this.contentField = value;
			OnPropertyChanged();
        }
    }
    
    public string contentString {
        get {
    		return Convert.ToBase64String(contentField);
        }        
    }
    
    [Required (ErrorMessage ="Поле \"Тип файла\" не заполнено.", AllowEmptyStrings = false)]
    /// <remarks/>    
    public recInfoProtocolMimetype? mimetype {
        get {
            return this.mimetypeField;
        }
        set {
    		
    		if (value == this.mimetypeField) return;
			this.mimetypeField = value;
			OnPropertyChanged();
			//this.mimetypeField = value;
        }
    }
    
    [Required (ErrorMessage ="Поле \"Наименование файла\" не заполнено.", AllowEmptyStrings = false)]
    /// <remarks/>   
    public string filename {
        get {
            return this.filenameField;
        }
        set {
	        if (value == this.filenameField) return;
	        this.filenameField = value;
	        OnPropertyChanged();
        }
    }
    
     /// <remarks/>   
    public string fullfilename {
        get {
            return this.fullfilenameField;
        }
        set {
            if (value == this.fullfilenameField) return;
			this.fullfilenameField = value;
			OnPropertyChanged();
        }
    }
}

/// <remarks/>
[System.SerializableAttribute()]
public enum recInfoProtocolMimetype {
    
    /// <remarks/>
    [Description("application/pdf")]
    [System.Xml.Serialization.XmlEnumAttribute("application/pdf")]
    applicationpdf,
    
    /// <remarks/>
    [Description("application/msword")]
    [System.Xml.Serialization.XmlEnumAttribute("application/msword")]
    applicationmsword,
    
    /// <remarks/>
    [Description("application/zip")]
    [System.Xml.Serialization.XmlEnumAttribute("application/zip")]
    applicationzip,
    
    /// <remarks/>
    [Description("image/vnd.djvu")]
    [System.Xml.Serialization.XmlEnumAttribute("image/vnd.djvu")]
    imagevnddjvu,
}

}
